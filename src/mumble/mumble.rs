// This file is generated by rust-protobuf 3.1.0. Do not edit
// .proto file is parsed by protoc 3.19.4
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `Mumble.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_1_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:MumbleProto.Version)
pub struct Version {
    // message fields
    // @@protoc_insertion_point(field:MumbleProto.Version.version)
    pub version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:MumbleProto.Version.release)
    pub release: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:MumbleProto.Version.os)
    pub os: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:MumbleProto.Version.os_version)
    pub os_version: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:MumbleProto.Version.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Version {
    fn default() -> &'a Version {
        <Version as ::protobuf::Message>::default_instance()
    }
}

impl Version {
    pub fn new() -> Version {
        ::std::default::Default::default()
    }

    // optional uint32 version = 1;

    pub fn version(&self) -> u32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional string release = 2;

    pub fn release(&self) -> &str {
        match self.release.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_release(&mut self) {
        self.release = ::std::option::Option::None;
    }

    pub fn has_release(&self) -> bool {
        self.release.is_some()
    }

    // Param is passed by value, moved
    pub fn set_release(&mut self, v: ::std::string::String) {
        self.release = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_release(&mut self) -> &mut ::std::string::String {
        if self.release.is_none() {
            self.release = ::std::option::Option::Some(::std::string::String::new());
        }
        self.release.as_mut().unwrap()
    }

    // Take field
    pub fn take_release(&mut self) -> ::std::string::String {
        self.release.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string os = 3;

    pub fn os(&self) -> &str {
        match self.os.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_os(&mut self) {
        self.os = ::std::option::Option::None;
    }

    pub fn has_os(&self) -> bool {
        self.os.is_some()
    }

    // Param is passed by value, moved
    pub fn set_os(&mut self, v: ::std::string::String) {
        self.os = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_os(&mut self) -> &mut ::std::string::String {
        if self.os.is_none() {
            self.os = ::std::option::Option::Some(::std::string::String::new());
        }
        self.os.as_mut().unwrap()
    }

    // Take field
    pub fn take_os(&mut self) -> ::std::string::String {
        self.os.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string os_version = 4;

    pub fn os_version(&self) -> &str {
        match self.os_version.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_os_version(&mut self) {
        self.os_version = ::std::option::Option::None;
    }

    pub fn has_os_version(&self) -> bool {
        self.os_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_os_version(&mut self, v: ::std::string::String) {
        self.os_version = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_os_version(&mut self) -> &mut ::std::string::String {
        if self.os_version.is_none() {
            self.os_version = ::std::option::Option::Some(::std::string::String::new());
        }
        self.os_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_os_version(&mut self) -> ::std::string::String {
        self.os_version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &Version| { &m.version },
            |m: &mut Version| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "release",
            |m: &Version| { &m.release },
            |m: &mut Version| { &mut m.release },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "os",
            |m: &Version| { &m.os },
            |m: &mut Version| { &mut m.os },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "os_version",
            |m: &Version| { &m.os_version },
            |m: &mut Version| { &mut m.os_version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Version>(
            "Version",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Version {
    const NAME: &'static str = "Version";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.version = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.release = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.os = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.os_version = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.release.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.os.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.os_version.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.release.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.os.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.os_version.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Version {
        Version::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.release = ::std::option::Option::None;
        self.os = ::std::option::Option::None;
        self.os_version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Version {
        static instance: Version = Version {
            version: ::std::option::Option::None,
            release: ::std::option::Option::None,
            os: ::std::option::Option::None,
            os_version: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Version {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Version").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Version {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Version {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:MumbleProto.UDPTunnel)
pub struct UDPTunnel {
    // message fields
    // @@protoc_insertion_point(field:MumbleProto.UDPTunnel.packet)
    pub packet: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:MumbleProto.UDPTunnel.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UDPTunnel {
    fn default() -> &'a UDPTunnel {
        <UDPTunnel as ::protobuf::Message>::default_instance()
    }
}

impl UDPTunnel {
    pub fn new() -> UDPTunnel {
        ::std::default::Default::default()
    }

    // required bytes packet = 1;

    pub fn packet(&self) -> &[u8] {
        match self.packet.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_packet(&mut self) {
        self.packet = ::std::option::Option::None;
    }

    pub fn has_packet(&self) -> bool {
        self.packet.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packet(&mut self, v: ::std::vec::Vec<u8>) {
        self.packet = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_packet(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.packet.is_none() {
            self.packet = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.packet.as_mut().unwrap()
    }

    // Take field
    pub fn take_packet(&mut self) -> ::std::vec::Vec<u8> {
        self.packet.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "packet",
            |m: &UDPTunnel| { &m.packet },
            |m: &mut UDPTunnel| { &mut m.packet },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UDPTunnel>(
            "UDPTunnel",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UDPTunnel {
    const NAME: &'static str = "UDPTunnel";

    fn is_initialized(&self) -> bool {
        if self.packet.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.packet = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.packet.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.packet.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UDPTunnel {
        UDPTunnel::new()
    }

    fn clear(&mut self) {
        self.packet = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UDPTunnel {
        static instance: UDPTunnel = UDPTunnel {
            packet: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UDPTunnel {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UDPTunnel").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UDPTunnel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UDPTunnel {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:MumbleProto.Authenticate)
pub struct Authenticate {
    // message fields
    // @@protoc_insertion_point(field:MumbleProto.Authenticate.username)
    pub username: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:MumbleProto.Authenticate.password)
    pub password: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:MumbleProto.Authenticate.tokens)
    pub tokens: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:MumbleProto.Authenticate.celt_versions)
    pub celt_versions: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:MumbleProto.Authenticate.opus)
    pub opus: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:MumbleProto.Authenticate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Authenticate {
    fn default() -> &'a Authenticate {
        <Authenticate as ::protobuf::Message>::default_instance()
    }
}

impl Authenticate {
    pub fn new() -> Authenticate {
        ::std::default::Default::default()
    }

    // optional string username = 1;

    pub fn username(&self) -> &str {
        match self.username.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_username(&mut self) {
        self.username = ::std::option::Option::None;
    }

    pub fn has_username(&self) -> bool {
        self.username.is_some()
    }

    // Param is passed by value, moved
    pub fn set_username(&mut self, v: ::std::string::String) {
        self.username = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_username(&mut self) -> &mut ::std::string::String {
        if self.username.is_none() {
            self.username = ::std::option::Option::Some(::std::string::String::new());
        }
        self.username.as_mut().unwrap()
    }

    // Take field
    pub fn take_username(&mut self) -> ::std::string::String {
        self.username.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string password = 2;

    pub fn password(&self) -> &str {
        match self.password.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_password(&mut self) {
        self.password = ::std::option::Option::None;
    }

    pub fn has_password(&self) -> bool {
        self.password.is_some()
    }

    // Param is passed by value, moved
    pub fn set_password(&mut self, v: ::std::string::String) {
        self.password = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_password(&mut self) -> &mut ::std::string::String {
        if self.password.is_none() {
            self.password = ::std::option::Option::Some(::std::string::String::new());
        }
        self.password.as_mut().unwrap()
    }

    // Take field
    pub fn take_password(&mut self) -> ::std::string::String {
        self.password.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool opus = 5;

    pub fn opus(&self) -> bool {
        self.opus.unwrap_or(false)
    }

    pub fn clear_opus(&mut self) {
        self.opus = ::std::option::Option::None;
    }

    pub fn has_opus(&self) -> bool {
        self.opus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_opus(&mut self, v: bool) {
        self.opus = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "username",
            |m: &Authenticate| { &m.username },
            |m: &mut Authenticate| { &mut m.username },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "password",
            |m: &Authenticate| { &m.password },
            |m: &mut Authenticate| { &mut m.password },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tokens",
            |m: &Authenticate| { &m.tokens },
            |m: &mut Authenticate| { &mut m.tokens },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "celt_versions",
            |m: &Authenticate| { &m.celt_versions },
            |m: &mut Authenticate| { &mut m.celt_versions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "opus",
            |m: &Authenticate| { &m.opus },
            |m: &mut Authenticate| { &mut m.opus },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Authenticate>(
            "Authenticate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Authenticate {
    const NAME: &'static str = "Authenticate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.username = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.password = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.tokens.push(is.read_string()?);
                },
                34 => {
                    is.read_repeated_packed_int32_into(&mut self.celt_versions)?;
                },
                32 => {
                    self.celt_versions.push(is.read_int32()?);
                },
                40 => {
                    self.opus = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.username.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.password.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.tokens {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.celt_versions {
            my_size += ::protobuf::rt::int32_size(4, *value);
        };
        if let Some(v) = self.opus {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.username.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.password.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.tokens {
            os.write_string(3, &v)?;
        };
        for v in &self.celt_versions {
            os.write_int32(4, *v)?;
        };
        if let Some(v) = self.opus {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Authenticate {
        Authenticate::new()
    }

    fn clear(&mut self) {
        self.username = ::std::option::Option::None;
        self.password = ::std::option::Option::None;
        self.tokens.clear();
        self.celt_versions.clear();
        self.opus = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Authenticate {
        static instance: Authenticate = Authenticate {
            username: ::std::option::Option::None,
            password: ::std::option::Option::None,
            tokens: ::std::vec::Vec::new(),
            celt_versions: ::std::vec::Vec::new(),
            opus: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Authenticate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Authenticate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Authenticate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Authenticate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:MumbleProto.Ping)
pub struct Ping {
    // message fields
    // @@protoc_insertion_point(field:MumbleProto.Ping.timestamp)
    pub timestamp: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:MumbleProto.Ping.good)
    pub good: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:MumbleProto.Ping.late)
    pub late: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:MumbleProto.Ping.lost)
    pub lost: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:MumbleProto.Ping.resync)
    pub resync: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:MumbleProto.Ping.udp_packets)
    pub udp_packets: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:MumbleProto.Ping.tcp_packets)
    pub tcp_packets: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:MumbleProto.Ping.udp_ping_avg)
    pub udp_ping_avg: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:MumbleProto.Ping.udp_ping_var)
    pub udp_ping_var: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:MumbleProto.Ping.tcp_ping_avg)
    pub tcp_ping_avg: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:MumbleProto.Ping.tcp_ping_var)
    pub tcp_ping_var: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:MumbleProto.Ping.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Ping {
    fn default() -> &'a Ping {
        <Ping as ::protobuf::Message>::default_instance()
    }
}

impl Ping {
    pub fn new() -> Ping {
        ::std::default::Default::default()
    }

    // optional uint64 timestamp = 1;

    pub fn timestamp(&self) -> u64 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u64) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 good = 2;

    pub fn good(&self) -> u32 {
        self.good.unwrap_or(0)
    }

    pub fn clear_good(&mut self) {
        self.good = ::std::option::Option::None;
    }

    pub fn has_good(&self) -> bool {
        self.good.is_some()
    }

    // Param is passed by value, moved
    pub fn set_good(&mut self, v: u32) {
        self.good = ::std::option::Option::Some(v);
    }

    // optional uint32 late = 3;

    pub fn late(&self) -> u32 {
        self.late.unwrap_or(0)
    }

    pub fn clear_late(&mut self) {
        self.late = ::std::option::Option::None;
    }

    pub fn has_late(&self) -> bool {
        self.late.is_some()
    }

    // Param is passed by value, moved
    pub fn set_late(&mut self, v: u32) {
        self.late = ::std::option::Option::Some(v);
    }

    // optional uint32 lost = 4;

    pub fn lost(&self) -> u32 {
        self.lost.unwrap_or(0)
    }

    pub fn clear_lost(&mut self) {
        self.lost = ::std::option::Option::None;
    }

    pub fn has_lost(&self) -> bool {
        self.lost.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lost(&mut self, v: u32) {
        self.lost = ::std::option::Option::Some(v);
    }

    // optional uint32 resync = 5;

    pub fn resync(&self) -> u32 {
        self.resync.unwrap_or(0)
    }

    pub fn clear_resync(&mut self) {
        self.resync = ::std::option::Option::None;
    }

    pub fn has_resync(&self) -> bool {
        self.resync.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resync(&mut self, v: u32) {
        self.resync = ::std::option::Option::Some(v);
    }

    // optional uint32 udp_packets = 6;

    pub fn udp_packets(&self) -> u32 {
        self.udp_packets.unwrap_or(0)
    }

    pub fn clear_udp_packets(&mut self) {
        self.udp_packets = ::std::option::Option::None;
    }

    pub fn has_udp_packets(&self) -> bool {
        self.udp_packets.is_some()
    }

    // Param is passed by value, moved
    pub fn set_udp_packets(&mut self, v: u32) {
        self.udp_packets = ::std::option::Option::Some(v);
    }

    // optional uint32 tcp_packets = 7;

    pub fn tcp_packets(&self) -> u32 {
        self.tcp_packets.unwrap_or(0)
    }

    pub fn clear_tcp_packets(&mut self) {
        self.tcp_packets = ::std::option::Option::None;
    }

    pub fn has_tcp_packets(&self) -> bool {
        self.tcp_packets.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tcp_packets(&mut self, v: u32) {
        self.tcp_packets = ::std::option::Option::Some(v);
    }

    // optional float udp_ping_avg = 8;

    pub fn udp_ping_avg(&self) -> f32 {
        self.udp_ping_avg.unwrap_or(0.)
    }

    pub fn clear_udp_ping_avg(&mut self) {
        self.udp_ping_avg = ::std::option::Option::None;
    }

    pub fn has_udp_ping_avg(&self) -> bool {
        self.udp_ping_avg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_udp_ping_avg(&mut self, v: f32) {
        self.udp_ping_avg = ::std::option::Option::Some(v);
    }

    // optional float udp_ping_var = 9;

    pub fn udp_ping_var(&self) -> f32 {
        self.udp_ping_var.unwrap_or(0.)
    }

    pub fn clear_udp_ping_var(&mut self) {
        self.udp_ping_var = ::std::option::Option::None;
    }

    pub fn has_udp_ping_var(&self) -> bool {
        self.udp_ping_var.is_some()
    }

    // Param is passed by value, moved
    pub fn set_udp_ping_var(&mut self, v: f32) {
        self.udp_ping_var = ::std::option::Option::Some(v);
    }

    // optional float tcp_ping_avg = 10;

    pub fn tcp_ping_avg(&self) -> f32 {
        self.tcp_ping_avg.unwrap_or(0.)
    }

    pub fn clear_tcp_ping_avg(&mut self) {
        self.tcp_ping_avg = ::std::option::Option::None;
    }

    pub fn has_tcp_ping_avg(&self) -> bool {
        self.tcp_ping_avg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tcp_ping_avg(&mut self, v: f32) {
        self.tcp_ping_avg = ::std::option::Option::Some(v);
    }

    // optional float tcp_ping_var = 11;

    pub fn tcp_ping_var(&self) -> f32 {
        self.tcp_ping_var.unwrap_or(0.)
    }

    pub fn clear_tcp_ping_var(&mut self) {
        self.tcp_ping_var = ::std::option::Option::None;
    }

    pub fn has_tcp_ping_var(&self) -> bool {
        self.tcp_ping_var.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tcp_ping_var(&mut self, v: f32) {
        self.tcp_ping_var = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &Ping| { &m.timestamp },
            |m: &mut Ping| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "good",
            |m: &Ping| { &m.good },
            |m: &mut Ping| { &mut m.good },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "late",
            |m: &Ping| { &m.late },
            |m: &mut Ping| { &mut m.late },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lost",
            |m: &Ping| { &m.lost },
            |m: &mut Ping| { &mut m.lost },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "resync",
            |m: &Ping| { &m.resync },
            |m: &mut Ping| { &mut m.resync },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "udp_packets",
            |m: &Ping| { &m.udp_packets },
            |m: &mut Ping| { &mut m.udp_packets },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tcp_packets",
            |m: &Ping| { &m.tcp_packets },
            |m: &mut Ping| { &mut m.tcp_packets },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "udp_ping_avg",
            |m: &Ping| { &m.udp_ping_avg },
            |m: &mut Ping| { &mut m.udp_ping_avg },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "udp_ping_var",
            |m: &Ping| { &m.udp_ping_var },
            |m: &mut Ping| { &mut m.udp_ping_var },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tcp_ping_avg",
            |m: &Ping| { &m.tcp_ping_avg },
            |m: &mut Ping| { &mut m.tcp_ping_avg },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tcp_ping_var",
            |m: &Ping| { &m.tcp_ping_var },
            |m: &mut Ping| { &mut m.tcp_ping_var },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Ping>(
            "Ping",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Ping {
    const NAME: &'static str = "Ping";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.timestamp = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.good = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.late = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.lost = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.resync = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.udp_packets = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.tcp_packets = ::std::option::Option::Some(is.read_uint32()?);
                },
                69 => {
                    self.udp_ping_avg = ::std::option::Option::Some(is.read_float()?);
                },
                77 => {
                    self.udp_ping_var = ::std::option::Option::Some(is.read_float()?);
                },
                85 => {
                    self.tcp_ping_avg = ::std::option::Option::Some(is.read_float()?);
                },
                93 => {
                    self.tcp_ping_var = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.good {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.late {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.lost {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.resync {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.udp_packets {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.tcp_packets {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.udp_ping_avg {
            my_size += 1 + 4;
        }
        if let Some(v) = self.udp_ping_var {
            my_size += 1 + 4;
        }
        if let Some(v) = self.tcp_ping_avg {
            my_size += 1 + 4;
        }
        if let Some(v) = self.tcp_ping_var {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.timestamp {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.good {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.late {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.lost {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.resync {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.udp_packets {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.tcp_packets {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.udp_ping_avg {
            os.write_float(8, v)?;
        }
        if let Some(v) = self.udp_ping_var {
            os.write_float(9, v)?;
        }
        if let Some(v) = self.tcp_ping_avg {
            os.write_float(10, v)?;
        }
        if let Some(v) = self.tcp_ping_var {
            os.write_float(11, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Ping {
        Ping::new()
    }

    fn clear(&mut self) {
        self.timestamp = ::std::option::Option::None;
        self.good = ::std::option::Option::None;
        self.late = ::std::option::Option::None;
        self.lost = ::std::option::Option::None;
        self.resync = ::std::option::Option::None;
        self.udp_packets = ::std::option::Option::None;
        self.tcp_packets = ::std::option::Option::None;
        self.udp_ping_avg = ::std::option::Option::None;
        self.udp_ping_var = ::std::option::Option::None;
        self.tcp_ping_avg = ::std::option::Option::None;
        self.tcp_ping_var = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Ping {
        static instance: Ping = Ping {
            timestamp: ::std::option::Option::None,
            good: ::std::option::Option::None,
            late: ::std::option::Option::None,
            lost: ::std::option::Option::None,
            resync: ::std::option::Option::None,
            udp_packets: ::std::option::Option::None,
            tcp_packets: ::std::option::Option::None,
            udp_ping_avg: ::std::option::Option::None,
            udp_ping_var: ::std::option::Option::None,
            tcp_ping_avg: ::std::option::Option::None,
            tcp_ping_var: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Ping {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Ping").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Ping {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Ping {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:MumbleProto.Reject)
pub struct Reject {
    // message fields
    // @@protoc_insertion_point(field:MumbleProto.Reject.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<reject::RejectType>>,
    // @@protoc_insertion_point(field:MumbleProto.Reject.reason)
    pub reason: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:MumbleProto.Reject.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Reject {
    fn default() -> &'a Reject {
        <Reject as ::protobuf::Message>::default_instance()
    }
}

impl Reject {
    pub fn new() -> Reject {
        ::std::default::Default::default()
    }

    // optional .MumbleProto.Reject.RejectType type = 1;

    pub fn type_(&self) -> reject::RejectType {
        match self.type_ {
            Some(e) => e.enum_value_or(reject::RejectType::None),
            None => reject::RejectType::None,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: reject::RejectType) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string reason = 2;

    pub fn reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason = ::std::option::Option::Some(::std::string::String::new());
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &Reject| { &m.type_ },
            |m: &mut Reject| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reason",
            |m: &Reject| { &m.reason },
            |m: &mut Reject| { &mut m.reason },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Reject>(
            "Reject",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Reject {
    const NAME: &'static str = "Reject";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.reason = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_ {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.reason.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Reject {
        Reject::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.reason = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Reject {
        static instance: Reject = Reject {
            type_: ::std::option::Option::None,
            reason: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Reject {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Reject").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Reject {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Reject {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Reject`
pub mod reject {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:MumbleProto.Reject.RejectType)
    pub enum RejectType {
        // @@protoc_insertion_point(enum_value:MumbleProto.Reject.RejectType.None)
        None = 0,
        // @@protoc_insertion_point(enum_value:MumbleProto.Reject.RejectType.WrongVersion)
        WrongVersion = 1,
        // @@protoc_insertion_point(enum_value:MumbleProto.Reject.RejectType.InvalidUsername)
        InvalidUsername = 2,
        // @@protoc_insertion_point(enum_value:MumbleProto.Reject.RejectType.WrongUserPW)
        WrongUserPW = 3,
        // @@protoc_insertion_point(enum_value:MumbleProto.Reject.RejectType.WrongServerPW)
        WrongServerPW = 4,
        // @@protoc_insertion_point(enum_value:MumbleProto.Reject.RejectType.UsernameInUse)
        UsernameInUse = 5,
        // @@protoc_insertion_point(enum_value:MumbleProto.Reject.RejectType.ServerFull)
        ServerFull = 6,
        // @@protoc_insertion_point(enum_value:MumbleProto.Reject.RejectType.NoCertificate)
        NoCertificate = 7,
        // @@protoc_insertion_point(enum_value:MumbleProto.Reject.RejectType.AuthenticatorFail)
        AuthenticatorFail = 8,
    }

    impl ::protobuf::Enum for RejectType {
        const NAME: &'static str = "RejectType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<RejectType> {
            match value {
                0 => ::std::option::Option::Some(RejectType::None),
                1 => ::std::option::Option::Some(RejectType::WrongVersion),
                2 => ::std::option::Option::Some(RejectType::InvalidUsername),
                3 => ::std::option::Option::Some(RejectType::WrongUserPW),
                4 => ::std::option::Option::Some(RejectType::WrongServerPW),
                5 => ::std::option::Option::Some(RejectType::UsernameInUse),
                6 => ::std::option::Option::Some(RejectType::ServerFull),
                7 => ::std::option::Option::Some(RejectType::NoCertificate),
                8 => ::std::option::Option::Some(RejectType::AuthenticatorFail),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [RejectType] = &[
            RejectType::None,
            RejectType::WrongVersion,
            RejectType::InvalidUsername,
            RejectType::WrongUserPW,
            RejectType::WrongServerPW,
            RejectType::UsernameInUse,
            RejectType::ServerFull,
            RejectType::NoCertificate,
            RejectType::AuthenticatorFail,
        ];
    }

    impl ::protobuf::EnumFull for RejectType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("Reject.RejectType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for RejectType {
        fn default() -> Self {
            RejectType::None
        }
    }

    impl RejectType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<RejectType>("Reject.RejectType")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:MumbleProto.ServerSync)
pub struct ServerSync {
    // message fields
    // @@protoc_insertion_point(field:MumbleProto.ServerSync.session)
    pub session: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:MumbleProto.ServerSync.max_bandwidth)
    pub max_bandwidth: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:MumbleProto.ServerSync.welcome_text)
    pub welcome_text: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:MumbleProto.ServerSync.permissions)
    pub permissions: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:MumbleProto.ServerSync.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ServerSync {
    fn default() -> &'a ServerSync {
        <ServerSync as ::protobuf::Message>::default_instance()
    }
}

impl ServerSync {
    pub fn new() -> ServerSync {
        ::std::default::Default::default()
    }

    // optional uint32 session = 1;

    pub fn session(&self) -> u32 {
        self.session.unwrap_or(0)
    }

    pub fn clear_session(&mut self) {
        self.session = ::std::option::Option::None;
    }

    pub fn has_session(&self) -> bool {
        self.session.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session(&mut self, v: u32) {
        self.session = ::std::option::Option::Some(v);
    }

    // optional uint32 max_bandwidth = 2;

    pub fn max_bandwidth(&self) -> u32 {
        self.max_bandwidth.unwrap_or(0)
    }

    pub fn clear_max_bandwidth(&mut self) {
        self.max_bandwidth = ::std::option::Option::None;
    }

    pub fn has_max_bandwidth(&self) -> bool {
        self.max_bandwidth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_bandwidth(&mut self, v: u32) {
        self.max_bandwidth = ::std::option::Option::Some(v);
    }

    // optional string welcome_text = 3;

    pub fn welcome_text(&self) -> &str {
        match self.welcome_text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_welcome_text(&mut self) {
        self.welcome_text = ::std::option::Option::None;
    }

    pub fn has_welcome_text(&self) -> bool {
        self.welcome_text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_welcome_text(&mut self, v: ::std::string::String) {
        self.welcome_text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_welcome_text(&mut self) -> &mut ::std::string::String {
        if self.welcome_text.is_none() {
            self.welcome_text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.welcome_text.as_mut().unwrap()
    }

    // Take field
    pub fn take_welcome_text(&mut self) -> ::std::string::String {
        self.welcome_text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 permissions = 4;

    pub fn permissions(&self) -> u64 {
        self.permissions.unwrap_or(0)
    }

    pub fn clear_permissions(&mut self) {
        self.permissions = ::std::option::Option::None;
    }

    pub fn has_permissions(&self) -> bool {
        self.permissions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_permissions(&mut self, v: u64) {
        self.permissions = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "session",
            |m: &ServerSync| { &m.session },
            |m: &mut ServerSync| { &mut m.session },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_bandwidth",
            |m: &ServerSync| { &m.max_bandwidth },
            |m: &mut ServerSync| { &mut m.max_bandwidth },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "welcome_text",
            |m: &ServerSync| { &m.welcome_text },
            |m: &mut ServerSync| { &mut m.welcome_text },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "permissions",
            |m: &ServerSync| { &m.permissions },
            |m: &mut ServerSync| { &mut m.permissions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ServerSync>(
            "ServerSync",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ServerSync {
    const NAME: &'static str = "ServerSync";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.session = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.max_bandwidth = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.welcome_text = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.permissions = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.session {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.max_bandwidth {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.welcome_text.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.permissions {
            my_size += ::protobuf::rt::uint64_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.session {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.max_bandwidth {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.welcome_text.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.permissions {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ServerSync {
        ServerSync::new()
    }

    fn clear(&mut self) {
        self.session = ::std::option::Option::None;
        self.max_bandwidth = ::std::option::Option::None;
        self.welcome_text = ::std::option::Option::None;
        self.permissions = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ServerSync {
        static instance: ServerSync = ServerSync {
            session: ::std::option::Option::None,
            max_bandwidth: ::std::option::Option::None,
            welcome_text: ::std::option::Option::None,
            permissions: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ServerSync {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ServerSync").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ServerSync {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServerSync {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:MumbleProto.ChannelRemove)
pub struct ChannelRemove {
    // message fields
    // @@protoc_insertion_point(field:MumbleProto.ChannelRemove.channel_id)
    pub channel_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:MumbleProto.ChannelRemove.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ChannelRemove {
    fn default() -> &'a ChannelRemove {
        <ChannelRemove as ::protobuf::Message>::default_instance()
    }
}

impl ChannelRemove {
    pub fn new() -> ChannelRemove {
        ::std::default::Default::default()
    }

    // required uint32 channel_id = 1;

    pub fn channel_id(&self) -> u32 {
        self.channel_id.unwrap_or(0)
    }

    pub fn clear_channel_id(&mut self) {
        self.channel_id = ::std::option::Option::None;
    }

    pub fn has_channel_id(&self) -> bool {
        self.channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel_id(&mut self, v: u32) {
        self.channel_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "channel_id",
            |m: &ChannelRemove| { &m.channel_id },
            |m: &mut ChannelRemove| { &mut m.channel_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ChannelRemove>(
            "ChannelRemove",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ChannelRemove {
    const NAME: &'static str = "ChannelRemove";

    fn is_initialized(&self) -> bool {
        if self.channel_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.channel_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.channel_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.channel_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ChannelRemove {
        ChannelRemove::new()
    }

    fn clear(&mut self) {
        self.channel_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ChannelRemove {
        static instance: ChannelRemove = ChannelRemove {
            channel_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ChannelRemove {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ChannelRemove").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ChannelRemove {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelRemove {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:MumbleProto.ChannelState)
pub struct ChannelState {
    // message fields
    // @@protoc_insertion_point(field:MumbleProto.ChannelState.channel_id)
    pub channel_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:MumbleProto.ChannelState.parent)
    pub parent: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:MumbleProto.ChannelState.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:MumbleProto.ChannelState.links)
    pub links: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:MumbleProto.ChannelState.description)
    pub description: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:MumbleProto.ChannelState.links_add)
    pub links_add: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:MumbleProto.ChannelState.links_remove)
    pub links_remove: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:MumbleProto.ChannelState.temporary)
    pub temporary: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:MumbleProto.ChannelState.position)
    pub position: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:MumbleProto.ChannelState.description_hash)
    pub description_hash: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:MumbleProto.ChannelState.max_users)
    pub max_users: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:MumbleProto.ChannelState.is_enter_restricted)
    pub is_enter_restricted: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:MumbleProto.ChannelState.can_enter)
    pub can_enter: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:MumbleProto.ChannelState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ChannelState {
    fn default() -> &'a ChannelState {
        <ChannelState as ::protobuf::Message>::default_instance()
    }
}

impl ChannelState {
    pub fn new() -> ChannelState {
        ::std::default::Default::default()
    }

    // optional uint32 channel_id = 1;

    pub fn channel_id(&self) -> u32 {
        self.channel_id.unwrap_or(0)
    }

    pub fn clear_channel_id(&mut self) {
        self.channel_id = ::std::option::Option::None;
    }

    pub fn has_channel_id(&self) -> bool {
        self.channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel_id(&mut self, v: u32) {
        self.channel_id = ::std::option::Option::Some(v);
    }

    // optional uint32 parent = 2;

    pub fn parent(&self) -> u32 {
        self.parent.unwrap_or(0)
    }

    pub fn clear_parent(&mut self) {
        self.parent = ::std::option::Option::None;
    }

    pub fn has_parent(&self) -> bool {
        self.parent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: u32) {
        self.parent = ::std::option::Option::Some(v);
    }

    // optional string name = 3;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string description = 5;

    pub fn description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_description(&mut self) {
        self.description = ::std::option::Option::None;
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool temporary = 8;

    pub fn temporary(&self) -> bool {
        self.temporary.unwrap_or(false)
    }

    pub fn clear_temporary(&mut self) {
        self.temporary = ::std::option::Option::None;
    }

    pub fn has_temporary(&self) -> bool {
        self.temporary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_temporary(&mut self, v: bool) {
        self.temporary = ::std::option::Option::Some(v);
    }

    // optional int32 position = 9;

    pub fn position(&self) -> i32 {
        self.position.unwrap_or(0i32)
    }

    pub fn clear_position(&mut self) {
        self.position = ::std::option::Option::None;
    }

    pub fn has_position(&self) -> bool {
        self.position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_position(&mut self, v: i32) {
        self.position = ::std::option::Option::Some(v);
    }

    // optional bytes description_hash = 10;

    pub fn description_hash(&self) -> &[u8] {
        match self.description_hash.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_description_hash(&mut self) {
        self.description_hash = ::std::option::Option::None;
    }

    pub fn has_description_hash(&self) -> bool {
        self.description_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.description_hash = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.description_hash.is_none() {
            self.description_hash = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.description_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_description_hash(&mut self) -> ::std::vec::Vec<u8> {
        self.description_hash.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 max_users = 11;

    pub fn max_users(&self) -> u32 {
        self.max_users.unwrap_or(0)
    }

    pub fn clear_max_users(&mut self) {
        self.max_users = ::std::option::Option::None;
    }

    pub fn has_max_users(&self) -> bool {
        self.max_users.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_users(&mut self, v: u32) {
        self.max_users = ::std::option::Option::Some(v);
    }

    // optional bool is_enter_restricted = 12;

    pub fn is_enter_restricted(&self) -> bool {
        self.is_enter_restricted.unwrap_or(false)
    }

    pub fn clear_is_enter_restricted(&mut self) {
        self.is_enter_restricted = ::std::option::Option::None;
    }

    pub fn has_is_enter_restricted(&self) -> bool {
        self.is_enter_restricted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_enter_restricted(&mut self, v: bool) {
        self.is_enter_restricted = ::std::option::Option::Some(v);
    }

    // optional bool can_enter = 13;

    pub fn can_enter(&self) -> bool {
        self.can_enter.unwrap_or(false)
    }

    pub fn clear_can_enter(&mut self) {
        self.can_enter = ::std::option::Option::None;
    }

    pub fn has_can_enter(&self) -> bool {
        self.can_enter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_enter(&mut self, v: bool) {
        self.can_enter = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(13);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "channel_id",
            |m: &ChannelState| { &m.channel_id },
            |m: &mut ChannelState| { &mut m.channel_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "parent",
            |m: &ChannelState| { &m.parent },
            |m: &mut ChannelState| { &mut m.parent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &ChannelState| { &m.name },
            |m: &mut ChannelState| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "links",
            |m: &ChannelState| { &m.links },
            |m: &mut ChannelState| { &mut m.links },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "description",
            |m: &ChannelState| { &m.description },
            |m: &mut ChannelState| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "links_add",
            |m: &ChannelState| { &m.links_add },
            |m: &mut ChannelState| { &mut m.links_add },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "links_remove",
            |m: &ChannelState| { &m.links_remove },
            |m: &mut ChannelState| { &mut m.links_remove },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "temporary",
            |m: &ChannelState| { &m.temporary },
            |m: &mut ChannelState| { &mut m.temporary },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "position",
            |m: &ChannelState| { &m.position },
            |m: &mut ChannelState| { &mut m.position },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "description_hash",
            |m: &ChannelState| { &m.description_hash },
            |m: &mut ChannelState| { &mut m.description_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_users",
            |m: &ChannelState| { &m.max_users },
            |m: &mut ChannelState| { &mut m.max_users },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_enter_restricted",
            |m: &ChannelState| { &m.is_enter_restricted },
            |m: &mut ChannelState| { &mut m.is_enter_restricted },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "can_enter",
            |m: &ChannelState| { &m.can_enter },
            |m: &mut ChannelState| { &mut m.can_enter },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ChannelState>(
            "ChannelState",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ChannelState {
    const NAME: &'static str = "ChannelState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.channel_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.parent = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    is.read_repeated_packed_uint32_into(&mut self.links)?;
                },
                32 => {
                    self.links.push(is.read_uint32()?);
                },
                42 => {
                    self.description = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    is.read_repeated_packed_uint32_into(&mut self.links_add)?;
                },
                48 => {
                    self.links_add.push(is.read_uint32()?);
                },
                58 => {
                    is.read_repeated_packed_uint32_into(&mut self.links_remove)?;
                },
                56 => {
                    self.links_remove.push(is.read_uint32()?);
                },
                64 => {
                    self.temporary = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.position = ::std::option::Option::Some(is.read_int32()?);
                },
                82 => {
                    self.description_hash = ::std::option::Option::Some(is.read_bytes()?);
                },
                88 => {
                    self.max_users = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.is_enter_restricted = ::std::option::Option::Some(is.read_bool()?);
                },
                104 => {
                    self.can_enter = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.channel_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.parent {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.links {
            my_size += ::protobuf::rt::uint32_size(4, *value);
        };
        if let Some(v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        for value in &self.links_add {
            my_size += ::protobuf::rt::uint32_size(6, *value);
        };
        for value in &self.links_remove {
            my_size += ::protobuf::rt::uint32_size(7, *value);
        };
        if let Some(v) = self.temporary {
            my_size += 1 + 1;
        }
        if let Some(v) = self.position {
            my_size += ::protobuf::rt::int32_size(9, v);
        }
        if let Some(v) = self.description_hash.as_ref() {
            my_size += ::protobuf::rt::bytes_size(10, &v);
        }
        if let Some(v) = self.max_users {
            my_size += ::protobuf::rt::uint32_size(11, v);
        }
        if let Some(v) = self.is_enter_restricted {
            my_size += 1 + 1;
        }
        if let Some(v) = self.can_enter {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.channel_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.parent {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(3, v)?;
        }
        for v in &self.links {
            os.write_uint32(4, *v)?;
        };
        if let Some(v) = self.description.as_ref() {
            os.write_string(5, v)?;
        }
        for v in &self.links_add {
            os.write_uint32(6, *v)?;
        };
        for v in &self.links_remove {
            os.write_uint32(7, *v)?;
        };
        if let Some(v) = self.temporary {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.position {
            os.write_int32(9, v)?;
        }
        if let Some(v) = self.description_hash.as_ref() {
            os.write_bytes(10, v)?;
        }
        if let Some(v) = self.max_users {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.is_enter_restricted {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.can_enter {
            os.write_bool(13, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ChannelState {
        ChannelState::new()
    }

    fn clear(&mut self) {
        self.channel_id = ::std::option::Option::None;
        self.parent = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.links.clear();
        self.description = ::std::option::Option::None;
        self.links_add.clear();
        self.links_remove.clear();
        self.temporary = ::std::option::Option::None;
        self.position = ::std::option::Option::None;
        self.description_hash = ::std::option::Option::None;
        self.max_users = ::std::option::Option::None;
        self.is_enter_restricted = ::std::option::Option::None;
        self.can_enter = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ChannelState {
        static instance: ChannelState = ChannelState {
            channel_id: ::std::option::Option::None,
            parent: ::std::option::Option::None,
            name: ::std::option::Option::None,
            links: ::std::vec::Vec::new(),
            description: ::std::option::Option::None,
            links_add: ::std::vec::Vec::new(),
            links_remove: ::std::vec::Vec::new(),
            temporary: ::std::option::Option::None,
            position: ::std::option::Option::None,
            description_hash: ::std::option::Option::None,
            max_users: ::std::option::Option::None,
            is_enter_restricted: ::std::option::Option::None,
            can_enter: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ChannelState {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ChannelState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ChannelState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelState {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:MumbleProto.UserRemove)
pub struct UserRemove {
    // message fields
    // @@protoc_insertion_point(field:MumbleProto.UserRemove.session)
    pub session: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:MumbleProto.UserRemove.actor)
    pub actor: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:MumbleProto.UserRemove.reason)
    pub reason: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:MumbleProto.UserRemove.ban)
    pub ban: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:MumbleProto.UserRemove.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UserRemove {
    fn default() -> &'a UserRemove {
        <UserRemove as ::protobuf::Message>::default_instance()
    }
}

impl UserRemove {
    pub fn new() -> UserRemove {
        ::std::default::Default::default()
    }

    // required uint32 session = 1;

    pub fn session(&self) -> u32 {
        self.session.unwrap_or(0)
    }

    pub fn clear_session(&mut self) {
        self.session = ::std::option::Option::None;
    }

    pub fn has_session(&self) -> bool {
        self.session.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session(&mut self, v: u32) {
        self.session = ::std::option::Option::Some(v);
    }

    // optional uint32 actor = 2;

    pub fn actor(&self) -> u32 {
        self.actor.unwrap_or(0)
    }

    pub fn clear_actor(&mut self) {
        self.actor = ::std::option::Option::None;
    }

    pub fn has_actor(&self) -> bool {
        self.actor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_actor(&mut self, v: u32) {
        self.actor = ::std::option::Option::Some(v);
    }

    // optional string reason = 3;

    pub fn reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason = ::std::option::Option::Some(::std::string::String::new());
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool ban = 4;

    pub fn ban(&self) -> bool {
        self.ban.unwrap_or(false)
    }

    pub fn clear_ban(&mut self) {
        self.ban = ::std::option::Option::None;
    }

    pub fn has_ban(&self) -> bool {
        self.ban.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ban(&mut self, v: bool) {
        self.ban = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "session",
            |m: &UserRemove| { &m.session },
            |m: &mut UserRemove| { &mut m.session },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "actor",
            |m: &UserRemove| { &m.actor },
            |m: &mut UserRemove| { &mut m.actor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reason",
            |m: &UserRemove| { &m.reason },
            |m: &mut UserRemove| { &mut m.reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ban",
            |m: &UserRemove| { &m.ban },
            |m: &mut UserRemove| { &mut m.ban },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserRemove>(
            "UserRemove",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UserRemove {
    const NAME: &'static str = "UserRemove";

    fn is_initialized(&self) -> bool {
        if self.session.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.session = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.actor = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.reason = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.ban = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.session {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.actor {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.ban {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.session {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.actor {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.reason.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.ban {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UserRemove {
        UserRemove::new()
    }

    fn clear(&mut self) {
        self.session = ::std::option::Option::None;
        self.actor = ::std::option::Option::None;
        self.reason = ::std::option::Option::None;
        self.ban = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UserRemove {
        static instance: UserRemove = UserRemove {
            session: ::std::option::Option::None,
            actor: ::std::option::Option::None,
            reason: ::std::option::Option::None,
            ban: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UserRemove {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UserRemove").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UserRemove {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserRemove {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:MumbleProto.UserState)
pub struct UserState {
    // message fields
    // @@protoc_insertion_point(field:MumbleProto.UserState.session)
    pub session: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:MumbleProto.UserState.actor)
    pub actor: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:MumbleProto.UserState.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:MumbleProto.UserState.user_id)
    pub user_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:MumbleProto.UserState.channel_id)
    pub channel_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:MumbleProto.UserState.mute)
    pub mute: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:MumbleProto.UserState.deaf)
    pub deaf: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:MumbleProto.UserState.suppress)
    pub suppress: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:MumbleProto.UserState.self_mute)
    pub self_mute: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:MumbleProto.UserState.self_deaf)
    pub self_deaf: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:MumbleProto.UserState.texture)
    pub texture: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:MumbleProto.UserState.plugin_context)
    pub plugin_context: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:MumbleProto.UserState.plugin_identity)
    pub plugin_identity: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:MumbleProto.UserState.comment)
    pub comment: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:MumbleProto.UserState.hash)
    pub hash: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:MumbleProto.UserState.comment_hash)
    pub comment_hash: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:MumbleProto.UserState.texture_hash)
    pub texture_hash: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:MumbleProto.UserState.priority_speaker)
    pub priority_speaker: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:MumbleProto.UserState.recording)
    pub recording: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:MumbleProto.UserState.temporary_access_tokens)
    pub temporary_access_tokens: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:MumbleProto.UserState.listening_channel_add)
    pub listening_channel_add: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:MumbleProto.UserState.listening_channel_remove)
    pub listening_channel_remove: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:MumbleProto.UserState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UserState {
    fn default() -> &'a UserState {
        <UserState as ::protobuf::Message>::default_instance()
    }
}

impl UserState {
    pub fn new() -> UserState {
        ::std::default::Default::default()
    }

    // optional uint32 session = 1;

    pub fn session(&self) -> u32 {
        self.session.unwrap_or(0)
    }

    pub fn clear_session(&mut self) {
        self.session = ::std::option::Option::None;
    }

    pub fn has_session(&self) -> bool {
        self.session.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session(&mut self, v: u32) {
        self.session = ::std::option::Option::Some(v);
    }

    // optional uint32 actor = 2;

    pub fn actor(&self) -> u32 {
        self.actor.unwrap_or(0)
    }

    pub fn clear_actor(&mut self) {
        self.actor = ::std::option::Option::None;
    }

    pub fn has_actor(&self) -> bool {
        self.actor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_actor(&mut self, v: u32) {
        self.actor = ::std::option::Option::Some(v);
    }

    // optional string name = 3;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 user_id = 4;

    pub fn user_id(&self) -> u32 {
        self.user_id.unwrap_or(0)
    }

    pub fn clear_user_id(&mut self) {
        self.user_id = ::std::option::Option::None;
    }

    pub fn has_user_id(&self) -> bool {
        self.user_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_id(&mut self, v: u32) {
        self.user_id = ::std::option::Option::Some(v);
    }

    // optional uint32 channel_id = 5;

    pub fn channel_id(&self) -> u32 {
        self.channel_id.unwrap_or(0)
    }

    pub fn clear_channel_id(&mut self) {
        self.channel_id = ::std::option::Option::None;
    }

    pub fn has_channel_id(&self) -> bool {
        self.channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel_id(&mut self, v: u32) {
        self.channel_id = ::std::option::Option::Some(v);
    }

    // optional bool mute = 6;

    pub fn mute(&self) -> bool {
        self.mute.unwrap_or(false)
    }

    pub fn clear_mute(&mut self) {
        self.mute = ::std::option::Option::None;
    }

    pub fn has_mute(&self) -> bool {
        self.mute.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mute(&mut self, v: bool) {
        self.mute = ::std::option::Option::Some(v);
    }

    // optional bool deaf = 7;

    pub fn deaf(&self) -> bool {
        self.deaf.unwrap_or(false)
    }

    pub fn clear_deaf(&mut self) {
        self.deaf = ::std::option::Option::None;
    }

    pub fn has_deaf(&self) -> bool {
        self.deaf.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deaf(&mut self, v: bool) {
        self.deaf = ::std::option::Option::Some(v);
    }

    // optional bool suppress = 8;

    pub fn suppress(&self) -> bool {
        self.suppress.unwrap_or(false)
    }

    pub fn clear_suppress(&mut self) {
        self.suppress = ::std::option::Option::None;
    }

    pub fn has_suppress(&self) -> bool {
        self.suppress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_suppress(&mut self, v: bool) {
        self.suppress = ::std::option::Option::Some(v);
    }

    // optional bool self_mute = 9;

    pub fn self_mute(&self) -> bool {
        self.self_mute.unwrap_or(false)
    }

    pub fn clear_self_mute(&mut self) {
        self.self_mute = ::std::option::Option::None;
    }

    pub fn has_self_mute(&self) -> bool {
        self.self_mute.is_some()
    }

    // Param is passed by value, moved
    pub fn set_self_mute(&mut self, v: bool) {
        self.self_mute = ::std::option::Option::Some(v);
    }

    // optional bool self_deaf = 10;

    pub fn self_deaf(&self) -> bool {
        self.self_deaf.unwrap_or(false)
    }

    pub fn clear_self_deaf(&mut self) {
        self.self_deaf = ::std::option::Option::None;
    }

    pub fn has_self_deaf(&self) -> bool {
        self.self_deaf.is_some()
    }

    // Param is passed by value, moved
    pub fn set_self_deaf(&mut self, v: bool) {
        self.self_deaf = ::std::option::Option::Some(v);
    }

    // optional bytes texture = 11;

    pub fn texture(&self) -> &[u8] {
        match self.texture.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_texture(&mut self) {
        self.texture = ::std::option::Option::None;
    }

    pub fn has_texture(&self) -> bool {
        self.texture.is_some()
    }

    // Param is passed by value, moved
    pub fn set_texture(&mut self, v: ::std::vec::Vec<u8>) {
        self.texture = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_texture(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.texture.is_none() {
            self.texture = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.texture.as_mut().unwrap()
    }

    // Take field
    pub fn take_texture(&mut self) -> ::std::vec::Vec<u8> {
        self.texture.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes plugin_context = 12;

    pub fn plugin_context(&self) -> &[u8] {
        match self.plugin_context.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_plugin_context(&mut self) {
        self.plugin_context = ::std::option::Option::None;
    }

    pub fn has_plugin_context(&self) -> bool {
        self.plugin_context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_plugin_context(&mut self, v: ::std::vec::Vec<u8>) {
        self.plugin_context = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_plugin_context(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.plugin_context.is_none() {
            self.plugin_context = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.plugin_context.as_mut().unwrap()
    }

    // Take field
    pub fn take_plugin_context(&mut self) -> ::std::vec::Vec<u8> {
        self.plugin_context.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string plugin_identity = 13;

    pub fn plugin_identity(&self) -> &str {
        match self.plugin_identity.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_plugin_identity(&mut self) {
        self.plugin_identity = ::std::option::Option::None;
    }

    pub fn has_plugin_identity(&self) -> bool {
        self.plugin_identity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_plugin_identity(&mut self, v: ::std::string::String) {
        self.plugin_identity = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_plugin_identity(&mut self) -> &mut ::std::string::String {
        if self.plugin_identity.is_none() {
            self.plugin_identity = ::std::option::Option::Some(::std::string::String::new());
        }
        self.plugin_identity.as_mut().unwrap()
    }

    // Take field
    pub fn take_plugin_identity(&mut self) -> ::std::string::String {
        self.plugin_identity.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string comment = 14;

    pub fn comment(&self) -> &str {
        match self.comment.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_comment(&mut self) {
        self.comment = ::std::option::Option::None;
    }

    pub fn has_comment(&self) -> bool {
        self.comment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_comment(&mut self, v: ::std::string::String) {
        self.comment = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_comment(&mut self) -> &mut ::std::string::String {
        if self.comment.is_none() {
            self.comment = ::std::option::Option::Some(::std::string::String::new());
        }
        self.comment.as_mut().unwrap()
    }

    // Take field
    pub fn take_comment(&mut self) -> ::std::string::String {
        self.comment.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string hash = 15;

    pub fn hash(&self) -> &str {
        match self.hash.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_hash(&mut self) {
        self.hash = ::std::option::Option::None;
    }

    pub fn has_hash(&self) -> bool {
        self.hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::string::String) {
        self.hash = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::string::String {
        if self.hash.is_none() {
            self.hash = ::std::option::Option::Some(::std::string::String::new());
        }
        self.hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::string::String {
        self.hash.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes comment_hash = 16;

    pub fn comment_hash(&self) -> &[u8] {
        match self.comment_hash.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_comment_hash(&mut self) {
        self.comment_hash = ::std::option::Option::None;
    }

    pub fn has_comment_hash(&self) -> bool {
        self.comment_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_comment_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.comment_hash = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_comment_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.comment_hash.is_none() {
            self.comment_hash = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.comment_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_comment_hash(&mut self) -> ::std::vec::Vec<u8> {
        self.comment_hash.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes texture_hash = 17;

    pub fn texture_hash(&self) -> &[u8] {
        match self.texture_hash.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_texture_hash(&mut self) {
        self.texture_hash = ::std::option::Option::None;
    }

    pub fn has_texture_hash(&self) -> bool {
        self.texture_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_texture_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.texture_hash = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_texture_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.texture_hash.is_none() {
            self.texture_hash = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.texture_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_texture_hash(&mut self) -> ::std::vec::Vec<u8> {
        self.texture_hash.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool priority_speaker = 18;

    pub fn priority_speaker(&self) -> bool {
        self.priority_speaker.unwrap_or(false)
    }

    pub fn clear_priority_speaker(&mut self) {
        self.priority_speaker = ::std::option::Option::None;
    }

    pub fn has_priority_speaker(&self) -> bool {
        self.priority_speaker.is_some()
    }

    // Param is passed by value, moved
    pub fn set_priority_speaker(&mut self, v: bool) {
        self.priority_speaker = ::std::option::Option::Some(v);
    }

    // optional bool recording = 19;

    pub fn recording(&self) -> bool {
        self.recording.unwrap_or(false)
    }

    pub fn clear_recording(&mut self) {
        self.recording = ::std::option::Option::None;
    }

    pub fn has_recording(&self) -> bool {
        self.recording.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recording(&mut self, v: bool) {
        self.recording = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(22);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "session",
            |m: &UserState| { &m.session },
            |m: &mut UserState| { &mut m.session },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "actor",
            |m: &UserState| { &m.actor },
            |m: &mut UserState| { &mut m.actor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &UserState| { &m.name },
            |m: &mut UserState| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "user_id",
            |m: &UserState| { &m.user_id },
            |m: &mut UserState| { &mut m.user_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "channel_id",
            |m: &UserState| { &m.channel_id },
            |m: &mut UserState| { &mut m.channel_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mute",
            |m: &UserState| { &m.mute },
            |m: &mut UserState| { &mut m.mute },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "deaf",
            |m: &UserState| { &m.deaf },
            |m: &mut UserState| { &mut m.deaf },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "suppress",
            |m: &UserState| { &m.suppress },
            |m: &mut UserState| { &mut m.suppress },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "self_mute",
            |m: &UserState| { &m.self_mute },
            |m: &mut UserState| { &mut m.self_mute },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "self_deaf",
            |m: &UserState| { &m.self_deaf },
            |m: &mut UserState| { &mut m.self_deaf },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "texture",
            |m: &UserState| { &m.texture },
            |m: &mut UserState| { &mut m.texture },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "plugin_context",
            |m: &UserState| { &m.plugin_context },
            |m: &mut UserState| { &mut m.plugin_context },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "plugin_identity",
            |m: &UserState| { &m.plugin_identity },
            |m: &mut UserState| { &mut m.plugin_identity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "comment",
            |m: &UserState| { &m.comment },
            |m: &mut UserState| { &mut m.comment },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hash",
            |m: &UserState| { &m.hash },
            |m: &mut UserState| { &mut m.hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "comment_hash",
            |m: &UserState| { &m.comment_hash },
            |m: &mut UserState| { &mut m.comment_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "texture_hash",
            |m: &UserState| { &m.texture_hash },
            |m: &mut UserState| { &mut m.texture_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "priority_speaker",
            |m: &UserState| { &m.priority_speaker },
            |m: &mut UserState| { &mut m.priority_speaker },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "recording",
            |m: &UserState| { &m.recording },
            |m: &mut UserState| { &mut m.recording },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "temporary_access_tokens",
            |m: &UserState| { &m.temporary_access_tokens },
            |m: &mut UserState| { &mut m.temporary_access_tokens },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "listening_channel_add",
            |m: &UserState| { &m.listening_channel_add },
            |m: &mut UserState| { &mut m.listening_channel_add },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "listening_channel_remove",
            |m: &UserState| { &m.listening_channel_remove },
            |m: &mut UserState| { &mut m.listening_channel_remove },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserState>(
            "UserState",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UserState {
    const NAME: &'static str = "UserState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.session = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.actor = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.user_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.channel_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.mute = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.deaf = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.suppress = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.self_mute = ::std::option::Option::Some(is.read_bool()?);
                },
                80 => {
                    self.self_deaf = ::std::option::Option::Some(is.read_bool()?);
                },
                90 => {
                    self.texture = ::std::option::Option::Some(is.read_bytes()?);
                },
                98 => {
                    self.plugin_context = ::std::option::Option::Some(is.read_bytes()?);
                },
                106 => {
                    self.plugin_identity = ::std::option::Option::Some(is.read_string()?);
                },
                114 => {
                    self.comment = ::std::option::Option::Some(is.read_string()?);
                },
                122 => {
                    self.hash = ::std::option::Option::Some(is.read_string()?);
                },
                130 => {
                    self.comment_hash = ::std::option::Option::Some(is.read_bytes()?);
                },
                138 => {
                    self.texture_hash = ::std::option::Option::Some(is.read_bytes()?);
                },
                144 => {
                    self.priority_speaker = ::std::option::Option::Some(is.read_bool()?);
                },
                152 => {
                    self.recording = ::std::option::Option::Some(is.read_bool()?);
                },
                162 => {
                    self.temporary_access_tokens.push(is.read_string()?);
                },
                170 => {
                    is.read_repeated_packed_uint32_into(&mut self.listening_channel_add)?;
                },
                168 => {
                    self.listening_channel_add.push(is.read_uint32()?);
                },
                178 => {
                    is.read_repeated_packed_uint32_into(&mut self.listening_channel_remove)?;
                },
                176 => {
                    self.listening_channel_remove.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.session {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.actor {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.user_id {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.channel_id {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.mute {
            my_size += 1 + 1;
        }
        if let Some(v) = self.deaf {
            my_size += 1 + 1;
        }
        if let Some(v) = self.suppress {
            my_size += 1 + 1;
        }
        if let Some(v) = self.self_mute {
            my_size += 1 + 1;
        }
        if let Some(v) = self.self_deaf {
            my_size += 1 + 1;
        }
        if let Some(v) = self.texture.as_ref() {
            my_size += ::protobuf::rt::bytes_size(11, &v);
        }
        if let Some(v) = self.plugin_context.as_ref() {
            my_size += ::protobuf::rt::bytes_size(12, &v);
        }
        if let Some(v) = self.plugin_identity.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(v) = self.comment.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        if let Some(v) = self.hash.as_ref() {
            my_size += ::protobuf::rt::string_size(15, &v);
        }
        if let Some(v) = self.comment_hash.as_ref() {
            my_size += ::protobuf::rt::bytes_size(16, &v);
        }
        if let Some(v) = self.texture_hash.as_ref() {
            my_size += ::protobuf::rt::bytes_size(17, &v);
        }
        if let Some(v) = self.priority_speaker {
            my_size += 2 + 1;
        }
        if let Some(v) = self.recording {
            my_size += 2 + 1;
        }
        for value in &self.temporary_access_tokens {
            my_size += ::protobuf::rt::string_size(20, &value);
        };
        for value in &self.listening_channel_add {
            my_size += ::protobuf::rt::uint32_size(21, *value);
        };
        for value in &self.listening_channel_remove {
            my_size += ::protobuf::rt::uint32_size(22, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.session {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.actor {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.user_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.channel_id {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.mute {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.deaf {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.suppress {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.self_mute {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.self_deaf {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.texture.as_ref() {
            os.write_bytes(11, v)?;
        }
        if let Some(v) = self.plugin_context.as_ref() {
            os.write_bytes(12, v)?;
        }
        if let Some(v) = self.plugin_identity.as_ref() {
            os.write_string(13, v)?;
        }
        if let Some(v) = self.comment.as_ref() {
            os.write_string(14, v)?;
        }
        if let Some(v) = self.hash.as_ref() {
            os.write_string(15, v)?;
        }
        if let Some(v) = self.comment_hash.as_ref() {
            os.write_bytes(16, v)?;
        }
        if let Some(v) = self.texture_hash.as_ref() {
            os.write_bytes(17, v)?;
        }
        if let Some(v) = self.priority_speaker {
            os.write_bool(18, v)?;
        }
        if let Some(v) = self.recording {
            os.write_bool(19, v)?;
        }
        for v in &self.temporary_access_tokens {
            os.write_string(20, &v)?;
        };
        for v in &self.listening_channel_add {
            os.write_uint32(21, *v)?;
        };
        for v in &self.listening_channel_remove {
            os.write_uint32(22, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UserState {
        UserState::new()
    }

    fn clear(&mut self) {
        self.session = ::std::option::Option::None;
        self.actor = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.user_id = ::std::option::Option::None;
        self.channel_id = ::std::option::Option::None;
        self.mute = ::std::option::Option::None;
        self.deaf = ::std::option::Option::None;
        self.suppress = ::std::option::Option::None;
        self.self_mute = ::std::option::Option::None;
        self.self_deaf = ::std::option::Option::None;
        self.texture = ::std::option::Option::None;
        self.plugin_context = ::std::option::Option::None;
        self.plugin_identity = ::std::option::Option::None;
        self.comment = ::std::option::Option::None;
        self.hash = ::std::option::Option::None;
        self.comment_hash = ::std::option::Option::None;
        self.texture_hash = ::std::option::Option::None;
        self.priority_speaker = ::std::option::Option::None;
        self.recording = ::std::option::Option::None;
        self.temporary_access_tokens.clear();
        self.listening_channel_add.clear();
        self.listening_channel_remove.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UserState {
        static instance: UserState = UserState {
            session: ::std::option::Option::None,
            actor: ::std::option::Option::None,
            name: ::std::option::Option::None,
            user_id: ::std::option::Option::None,
            channel_id: ::std::option::Option::None,
            mute: ::std::option::Option::None,
            deaf: ::std::option::Option::None,
            suppress: ::std::option::Option::None,
            self_mute: ::std::option::Option::None,
            self_deaf: ::std::option::Option::None,
            texture: ::std::option::Option::None,
            plugin_context: ::std::option::Option::None,
            plugin_identity: ::std::option::Option::None,
            comment: ::std::option::Option::None,
            hash: ::std::option::Option::None,
            comment_hash: ::std::option::Option::None,
            texture_hash: ::std::option::Option::None,
            priority_speaker: ::std::option::Option::None,
            recording: ::std::option::Option::None,
            temporary_access_tokens: ::std::vec::Vec::new(),
            listening_channel_add: ::std::vec::Vec::new(),
            listening_channel_remove: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UserState {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UserState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UserState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserState {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:MumbleProto.BanList)
pub struct BanList {
    // message fields
    // @@protoc_insertion_point(field:MumbleProto.BanList.bans)
    pub bans: ::std::vec::Vec<ban_list::BanEntry>,
    // @@protoc_insertion_point(field:MumbleProto.BanList.query)
    pub query: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:MumbleProto.BanList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BanList {
    fn default() -> &'a BanList {
        <BanList as ::protobuf::Message>::default_instance()
    }
}

impl BanList {
    pub fn new() -> BanList {
        ::std::default::Default::default()
    }

    // optional bool query = 2;

    pub fn query(&self) -> bool {
        self.query.unwrap_or(false)
    }

    pub fn clear_query(&mut self) {
        self.query = ::std::option::Option::None;
    }

    pub fn has_query(&self) -> bool {
        self.query.is_some()
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: bool) {
        self.query = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "bans",
            |m: &BanList| { &m.bans },
            |m: &mut BanList| { &mut m.bans },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "query",
            |m: &BanList| { &m.query },
            |m: &mut BanList| { &mut m.query },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BanList>(
            "BanList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BanList {
    const NAME: &'static str = "BanList";

    fn is_initialized(&self) -> bool {
        for v in &self.bans {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.bans.push(is.read_message()?);
                },
                16 => {
                    self.query = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.bans {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.query {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.bans {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.query {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BanList {
        BanList::new()
    }

    fn clear(&mut self) {
        self.bans.clear();
        self.query = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BanList {
        static instance: BanList = BanList {
            bans: ::std::vec::Vec::new(),
            query: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BanList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BanList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BanList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BanList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `BanList`
pub mod ban_list {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:MumbleProto.BanList.BanEntry)
    pub struct BanEntry {
        // message fields
        // @@protoc_insertion_point(field:MumbleProto.BanList.BanEntry.address)
        pub address: ::std::option::Option<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:MumbleProto.BanList.BanEntry.mask)
        pub mask: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:MumbleProto.BanList.BanEntry.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:MumbleProto.BanList.BanEntry.hash)
        pub hash: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:MumbleProto.BanList.BanEntry.reason)
        pub reason: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:MumbleProto.BanList.BanEntry.start)
        pub start: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:MumbleProto.BanList.BanEntry.duration)
        pub duration: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:MumbleProto.BanList.BanEntry.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a BanEntry {
        fn default() -> &'a BanEntry {
            <BanEntry as ::protobuf::Message>::default_instance()
        }
    }

    impl BanEntry {
        pub fn new() -> BanEntry {
            ::std::default::Default::default()
        }

        // required bytes address = 1;

        pub fn address(&self) -> &[u8] {
            match self.address.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_address(&mut self) {
            self.address = ::std::option::Option::None;
        }

        pub fn has_address(&self) -> bool {
            self.address.is_some()
        }

        // Param is passed by value, moved
        pub fn set_address(&mut self, v: ::std::vec::Vec<u8>) {
            self.address = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_address(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.address.is_none() {
                self.address = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.address.as_mut().unwrap()
        }

        // Take field
        pub fn take_address(&mut self) -> ::std::vec::Vec<u8> {
            self.address.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // required uint32 mask = 2;

        pub fn mask(&self) -> u32 {
            self.mask.unwrap_or(0)
        }

        pub fn clear_mask(&mut self) {
            self.mask = ::std::option::Option::None;
        }

        pub fn has_mask(&self) -> bool {
            self.mask.is_some()
        }

        // Param is passed by value, moved
        pub fn set_mask(&mut self, v: u32) {
            self.mask = ::std::option::Option::Some(v);
        }

        // optional string name = 3;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string hash = 4;

        pub fn hash(&self) -> &str {
            match self.hash.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_hash(&mut self) {
            self.hash = ::std::option::Option::None;
        }

        pub fn has_hash(&self) -> bool {
            self.hash.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hash(&mut self, v: ::std::string::String) {
            self.hash = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_hash(&mut self) -> &mut ::std::string::String {
            if self.hash.is_none() {
                self.hash = ::std::option::Option::Some(::std::string::String::new());
            }
            self.hash.as_mut().unwrap()
        }

        // Take field
        pub fn take_hash(&mut self) -> ::std::string::String {
            self.hash.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string reason = 5;

        pub fn reason(&self) -> &str {
            match self.reason.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_reason(&mut self) {
            self.reason = ::std::option::Option::None;
        }

        pub fn has_reason(&self) -> bool {
            self.reason.is_some()
        }

        // Param is passed by value, moved
        pub fn set_reason(&mut self, v: ::std::string::String) {
            self.reason = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_reason(&mut self) -> &mut ::std::string::String {
            if self.reason.is_none() {
                self.reason = ::std::option::Option::Some(::std::string::String::new());
            }
            self.reason.as_mut().unwrap()
        }

        // Take field
        pub fn take_reason(&mut self) -> ::std::string::String {
            self.reason.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string start = 6;

        pub fn start(&self) -> &str {
            match self.start.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_start(&mut self) {
            self.start = ::std::option::Option::None;
        }

        pub fn has_start(&self) -> bool {
            self.start.is_some()
        }

        // Param is passed by value, moved
        pub fn set_start(&mut self, v: ::std::string::String) {
            self.start = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_start(&mut self) -> &mut ::std::string::String {
            if self.start.is_none() {
                self.start = ::std::option::Option::Some(::std::string::String::new());
            }
            self.start.as_mut().unwrap()
        }

        // Take field
        pub fn take_start(&mut self) -> ::std::string::String {
            self.start.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 duration = 7;

        pub fn duration(&self) -> u32 {
            self.duration.unwrap_or(0)
        }

        pub fn clear_duration(&mut self) {
            self.duration = ::std::option::Option::None;
        }

        pub fn has_duration(&self) -> bool {
            self.duration.is_some()
        }

        // Param is passed by value, moved
        pub fn set_duration(&mut self, v: u32) {
            self.duration = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(7);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "address",
                |m: &BanEntry| { &m.address },
                |m: &mut BanEntry| { &mut m.address },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "mask",
                |m: &BanEntry| { &m.mask },
                |m: &mut BanEntry| { &mut m.mask },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &BanEntry| { &m.name },
                |m: &mut BanEntry| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "hash",
                |m: &BanEntry| { &m.hash },
                |m: &mut BanEntry| { &mut m.hash },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "reason",
                |m: &BanEntry| { &m.reason },
                |m: &mut BanEntry| { &mut m.reason },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "start",
                |m: &BanEntry| { &m.start },
                |m: &mut BanEntry| { &mut m.start },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "duration",
                |m: &BanEntry| { &m.duration },
                |m: &mut BanEntry| { &mut m.duration },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BanEntry>(
                "BanList.BanEntry",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for BanEntry {
        const NAME: &'static str = "BanEntry";

        fn is_initialized(&self) -> bool {
            if self.address.is_none() {
                return false;
            }
            if self.mask.is_none() {
                return false;
            }
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.address = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    16 => {
                        self.mask = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    26 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    34 => {
                        self.hash = ::std::option::Option::Some(is.read_string()?);
                    },
                    42 => {
                        self.reason = ::std::option::Option::Some(is.read_string()?);
                    },
                    50 => {
                        self.start = ::std::option::Option::Some(is.read_string()?);
                    },
                    56 => {
                        self.duration = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.address.as_ref() {
                my_size += ::protobuf::rt::bytes_size(1, &v);
            }
            if let Some(v) = self.mask {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.hash.as_ref() {
                my_size += ::protobuf::rt::string_size(4, &v);
            }
            if let Some(v) = self.reason.as_ref() {
                my_size += ::protobuf::rt::string_size(5, &v);
            }
            if let Some(v) = self.start.as_ref() {
                my_size += ::protobuf::rt::string_size(6, &v);
            }
            if let Some(v) = self.duration {
                my_size += ::protobuf::rt::uint32_size(7, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.address.as_ref() {
                os.write_bytes(1, v)?;
            }
            if let Some(v) = self.mask {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.hash.as_ref() {
                os.write_string(4, v)?;
            }
            if let Some(v) = self.reason.as_ref() {
                os.write_string(5, v)?;
            }
            if let Some(v) = self.start.as_ref() {
                os.write_string(6, v)?;
            }
            if let Some(v) = self.duration {
                os.write_uint32(7, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> BanEntry {
            BanEntry::new()
        }

        fn clear(&mut self) {
            self.address = ::std::option::Option::None;
            self.mask = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.hash = ::std::option::Option::None;
            self.reason = ::std::option::Option::None;
            self.start = ::std::option::Option::None;
            self.duration = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static BanEntry {
            static instance: BanEntry = BanEntry {
                address: ::std::option::Option::None,
                mask: ::std::option::Option::None,
                name: ::std::option::Option::None,
                hash: ::std::option::Option::None,
                reason: ::std::option::Option::None,
                start: ::std::option::Option::None,
                duration: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for BanEntry {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("BanList.BanEntry").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for BanEntry {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for BanEntry {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:MumbleProto.TextMessage)
pub struct TextMessage {
    // message fields
    // @@protoc_insertion_point(field:MumbleProto.TextMessage.actor)
    pub actor: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:MumbleProto.TextMessage.session)
    pub session: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:MumbleProto.TextMessage.channel_id)
    pub channel_id: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:MumbleProto.TextMessage.tree_id)
    pub tree_id: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:MumbleProto.TextMessage.message)
    pub message: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:MumbleProto.TextMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TextMessage {
    fn default() -> &'a TextMessage {
        <TextMessage as ::protobuf::Message>::default_instance()
    }
}

impl TextMessage {
    pub fn new() -> TextMessage {
        ::std::default::Default::default()
    }

    // optional uint32 actor = 1;

    pub fn actor(&self) -> u32 {
        self.actor.unwrap_or(0)
    }

    pub fn clear_actor(&mut self) {
        self.actor = ::std::option::Option::None;
    }

    pub fn has_actor(&self) -> bool {
        self.actor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_actor(&mut self, v: u32) {
        self.actor = ::std::option::Option::Some(v);
    }

    // required string message = 5;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "actor",
            |m: &TextMessage| { &m.actor },
            |m: &mut TextMessage| { &mut m.actor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "session",
            |m: &TextMessage| { &m.session },
            |m: &mut TextMessage| { &mut m.session },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "channel_id",
            |m: &TextMessage| { &m.channel_id },
            |m: &mut TextMessage| { &mut m.channel_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tree_id",
            |m: &TextMessage| { &m.tree_id },
            |m: &mut TextMessage| { &mut m.tree_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &TextMessage| { &m.message },
            |m: &mut TextMessage| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TextMessage>(
            "TextMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TextMessage {
    const NAME: &'static str = "TextMessage";

    fn is_initialized(&self) -> bool {
        if self.message.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.actor = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.session)?;
                },
                16 => {
                    self.session.push(is.read_uint32()?);
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.channel_id)?;
                },
                24 => {
                    self.channel_id.push(is.read_uint32()?);
                },
                34 => {
                    is.read_repeated_packed_uint32_into(&mut self.tree_id)?;
                },
                32 => {
                    self.tree_id.push(is.read_uint32()?);
                },
                42 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.actor {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.session {
            my_size += ::protobuf::rt::uint32_size(2, *value);
        };
        for value in &self.channel_id {
            my_size += ::protobuf::rt::uint32_size(3, *value);
        };
        for value in &self.tree_id {
            my_size += ::protobuf::rt::uint32_size(4, *value);
        };
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.actor {
            os.write_uint32(1, v)?;
        }
        for v in &self.session {
            os.write_uint32(2, *v)?;
        };
        for v in &self.channel_id {
            os.write_uint32(3, *v)?;
        };
        for v in &self.tree_id {
            os.write_uint32(4, *v)?;
        };
        if let Some(v) = self.message.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TextMessage {
        TextMessage::new()
    }

    fn clear(&mut self) {
        self.actor = ::std::option::Option::None;
        self.session.clear();
        self.channel_id.clear();
        self.tree_id.clear();
        self.message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TextMessage {
        static instance: TextMessage = TextMessage {
            actor: ::std::option::Option::None,
            session: ::std::vec::Vec::new(),
            channel_id: ::std::vec::Vec::new(),
            tree_id: ::std::vec::Vec::new(),
            message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TextMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TextMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TextMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TextMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:MumbleProto.PermissionDenied)
pub struct PermissionDenied {
    // message fields
    // @@protoc_insertion_point(field:MumbleProto.PermissionDenied.permission)
    pub permission: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:MumbleProto.PermissionDenied.channel_id)
    pub channel_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:MumbleProto.PermissionDenied.session)
    pub session: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:MumbleProto.PermissionDenied.reason)
    pub reason: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:MumbleProto.PermissionDenied.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<permission_denied::DenyType>>,
    // @@protoc_insertion_point(field:MumbleProto.PermissionDenied.name)
    pub name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:MumbleProto.PermissionDenied.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PermissionDenied {
    fn default() -> &'a PermissionDenied {
        <PermissionDenied as ::protobuf::Message>::default_instance()
    }
}

impl PermissionDenied {
    pub fn new() -> PermissionDenied {
        ::std::default::Default::default()
    }

    // optional uint32 permission = 1;

    pub fn permission(&self) -> u32 {
        self.permission.unwrap_or(0)
    }

    pub fn clear_permission(&mut self) {
        self.permission = ::std::option::Option::None;
    }

    pub fn has_permission(&self) -> bool {
        self.permission.is_some()
    }

    // Param is passed by value, moved
    pub fn set_permission(&mut self, v: u32) {
        self.permission = ::std::option::Option::Some(v);
    }

    // optional uint32 channel_id = 2;

    pub fn channel_id(&self) -> u32 {
        self.channel_id.unwrap_or(0)
    }

    pub fn clear_channel_id(&mut self) {
        self.channel_id = ::std::option::Option::None;
    }

    pub fn has_channel_id(&self) -> bool {
        self.channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel_id(&mut self, v: u32) {
        self.channel_id = ::std::option::Option::Some(v);
    }

    // optional uint32 session = 3;

    pub fn session(&self) -> u32 {
        self.session.unwrap_or(0)
    }

    pub fn clear_session(&mut self) {
        self.session = ::std::option::Option::None;
    }

    pub fn has_session(&self) -> bool {
        self.session.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session(&mut self, v: u32) {
        self.session = ::std::option::Option::Some(v);
    }

    // optional string reason = 4;

    pub fn reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason = ::std::option::Option::Some(::std::string::String::new());
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .MumbleProto.PermissionDenied.DenyType type = 5;

    pub fn type_(&self) -> permission_denied::DenyType {
        match self.type_ {
            Some(e) => e.enum_value_or(permission_denied::DenyType::Text),
            None => permission_denied::DenyType::Text,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: permission_denied::DenyType) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string name = 6;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "permission",
            |m: &PermissionDenied| { &m.permission },
            |m: &mut PermissionDenied| { &mut m.permission },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "channel_id",
            |m: &PermissionDenied| { &m.channel_id },
            |m: &mut PermissionDenied| { &mut m.channel_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "session",
            |m: &PermissionDenied| { &m.session },
            |m: &mut PermissionDenied| { &mut m.session },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reason",
            |m: &PermissionDenied| { &m.reason },
            |m: &mut PermissionDenied| { &mut m.reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &PermissionDenied| { &m.type_ },
            |m: &mut PermissionDenied| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &PermissionDenied| { &m.name },
            |m: &mut PermissionDenied| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PermissionDenied>(
            "PermissionDenied",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PermissionDenied {
    const NAME: &'static str = "PermissionDenied";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.permission = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.channel_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.session = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.reason = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                50 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.permission {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.channel_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.session {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(5, v.value());
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.permission {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.channel_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.session {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.reason.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.type_ {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PermissionDenied {
        PermissionDenied::new()
    }

    fn clear(&mut self) {
        self.permission = ::std::option::Option::None;
        self.channel_id = ::std::option::Option::None;
        self.session = ::std::option::Option::None;
        self.reason = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PermissionDenied {
        static instance: PermissionDenied = PermissionDenied {
            permission: ::std::option::Option::None,
            channel_id: ::std::option::Option::None,
            session: ::std::option::Option::None,
            reason: ::std::option::Option::None,
            type_: ::std::option::Option::None,
            name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PermissionDenied {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PermissionDenied").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PermissionDenied {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PermissionDenied {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `PermissionDenied`
pub mod permission_denied {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:MumbleProto.PermissionDenied.DenyType)
    pub enum DenyType {
        // @@protoc_insertion_point(enum_value:MumbleProto.PermissionDenied.DenyType.Text)
        Text = 0,
        // @@protoc_insertion_point(enum_value:MumbleProto.PermissionDenied.DenyType.Permission)
        Permission = 1,
        // @@protoc_insertion_point(enum_value:MumbleProto.PermissionDenied.DenyType.SuperUser)
        SuperUser = 2,
        // @@protoc_insertion_point(enum_value:MumbleProto.PermissionDenied.DenyType.ChannelName)
        ChannelName = 3,
        // @@protoc_insertion_point(enum_value:MumbleProto.PermissionDenied.DenyType.TextTooLong)
        TextTooLong = 4,
        // @@protoc_insertion_point(enum_value:MumbleProto.PermissionDenied.DenyType.H9K)
        H9K = 5,
        // @@protoc_insertion_point(enum_value:MumbleProto.PermissionDenied.DenyType.TemporaryChannel)
        TemporaryChannel = 6,
        // @@protoc_insertion_point(enum_value:MumbleProto.PermissionDenied.DenyType.MissingCertificate)
        MissingCertificate = 7,
        // @@protoc_insertion_point(enum_value:MumbleProto.PermissionDenied.DenyType.UserName)
        UserName = 8,
        // @@protoc_insertion_point(enum_value:MumbleProto.PermissionDenied.DenyType.ChannelFull)
        ChannelFull = 9,
        // @@protoc_insertion_point(enum_value:MumbleProto.PermissionDenied.DenyType.NestingLimit)
        NestingLimit = 10,
        // @@protoc_insertion_point(enum_value:MumbleProto.PermissionDenied.DenyType.ChannelCountLimit)
        ChannelCountLimit = 11,
        // @@protoc_insertion_point(enum_value:MumbleProto.PermissionDenied.DenyType.ChannelListenerLimit)
        ChannelListenerLimit = 12,
        // @@protoc_insertion_point(enum_value:MumbleProto.PermissionDenied.DenyType.UserListenerLimit)
        UserListenerLimit = 13,
    }

    impl ::protobuf::Enum for DenyType {
        const NAME: &'static str = "DenyType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<DenyType> {
            match value {
                0 => ::std::option::Option::Some(DenyType::Text),
                1 => ::std::option::Option::Some(DenyType::Permission),
                2 => ::std::option::Option::Some(DenyType::SuperUser),
                3 => ::std::option::Option::Some(DenyType::ChannelName),
                4 => ::std::option::Option::Some(DenyType::TextTooLong),
                5 => ::std::option::Option::Some(DenyType::H9K),
                6 => ::std::option::Option::Some(DenyType::TemporaryChannel),
                7 => ::std::option::Option::Some(DenyType::MissingCertificate),
                8 => ::std::option::Option::Some(DenyType::UserName),
                9 => ::std::option::Option::Some(DenyType::ChannelFull),
                10 => ::std::option::Option::Some(DenyType::NestingLimit),
                11 => ::std::option::Option::Some(DenyType::ChannelCountLimit),
                12 => ::std::option::Option::Some(DenyType::ChannelListenerLimit),
                13 => ::std::option::Option::Some(DenyType::UserListenerLimit),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [DenyType] = &[
            DenyType::Text,
            DenyType::Permission,
            DenyType::SuperUser,
            DenyType::ChannelName,
            DenyType::TextTooLong,
            DenyType::H9K,
            DenyType::TemporaryChannel,
            DenyType::MissingCertificate,
            DenyType::UserName,
            DenyType::ChannelFull,
            DenyType::NestingLimit,
            DenyType::ChannelCountLimit,
            DenyType::ChannelListenerLimit,
            DenyType::UserListenerLimit,
        ];
    }

    impl ::protobuf::EnumFull for DenyType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("PermissionDenied.DenyType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for DenyType {
        fn default() -> Self {
            DenyType::Text
        }
    }

    impl DenyType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<DenyType>("PermissionDenied.DenyType")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:MumbleProto.ACL)
pub struct ACL {
    // message fields
    // @@protoc_insertion_point(field:MumbleProto.ACL.channel_id)
    pub channel_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:MumbleProto.ACL.inherit_acls)
    pub inherit_acls: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:MumbleProto.ACL.groups)
    pub groups: ::std::vec::Vec<acl::ChanGroup>,
    // @@protoc_insertion_point(field:MumbleProto.ACL.acls)
    pub acls: ::std::vec::Vec<acl::ChanACL>,
    // @@protoc_insertion_point(field:MumbleProto.ACL.query)
    pub query: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:MumbleProto.ACL.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ACL {
    fn default() -> &'a ACL {
        <ACL as ::protobuf::Message>::default_instance()
    }
}

impl ACL {
    pub fn new() -> ACL {
        ::std::default::Default::default()
    }

    // required uint32 channel_id = 1;

    pub fn channel_id(&self) -> u32 {
        self.channel_id.unwrap_or(0)
    }

    pub fn clear_channel_id(&mut self) {
        self.channel_id = ::std::option::Option::None;
    }

    pub fn has_channel_id(&self) -> bool {
        self.channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel_id(&mut self, v: u32) {
        self.channel_id = ::std::option::Option::Some(v);
    }

    // optional bool inherit_acls = 2;

    pub fn inherit_acls(&self) -> bool {
        self.inherit_acls.unwrap_or(true)
    }

    pub fn clear_inherit_acls(&mut self) {
        self.inherit_acls = ::std::option::Option::None;
    }

    pub fn has_inherit_acls(&self) -> bool {
        self.inherit_acls.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inherit_acls(&mut self, v: bool) {
        self.inherit_acls = ::std::option::Option::Some(v);
    }

    // optional bool query = 5;

    pub fn query(&self) -> bool {
        self.query.unwrap_or(false)
    }

    pub fn clear_query(&mut self) {
        self.query = ::std::option::Option::None;
    }

    pub fn has_query(&self) -> bool {
        self.query.is_some()
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: bool) {
        self.query = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "channel_id",
            |m: &ACL| { &m.channel_id },
            |m: &mut ACL| { &mut m.channel_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "inherit_acls",
            |m: &ACL| { &m.inherit_acls },
            |m: &mut ACL| { &mut m.inherit_acls },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "groups",
            |m: &ACL| { &m.groups },
            |m: &mut ACL| { &mut m.groups },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "acls",
            |m: &ACL| { &m.acls },
            |m: &mut ACL| { &mut m.acls },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "query",
            |m: &ACL| { &m.query },
            |m: &mut ACL| { &mut m.query },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ACL>(
            "ACL",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ACL {
    const NAME: &'static str = "ACL";

    fn is_initialized(&self) -> bool {
        if self.channel_id.is_none() {
            return false;
        }
        for v in &self.groups {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.acls {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.channel_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.inherit_acls = ::std::option::Option::Some(is.read_bool()?);
                },
                26 => {
                    self.groups.push(is.read_message()?);
                },
                34 => {
                    self.acls.push(is.read_message()?);
                },
                40 => {
                    self.query = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.channel_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.inherit_acls {
            my_size += 1 + 1;
        }
        for value in &self.groups {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.acls {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.query {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.channel_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.inherit_acls {
            os.write_bool(2, v)?;
        }
        for v in &self.groups {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.acls {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.query {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ACL {
        ACL::new()
    }

    fn clear(&mut self) {
        self.channel_id = ::std::option::Option::None;
        self.inherit_acls = ::std::option::Option::None;
        self.groups.clear();
        self.acls.clear();
        self.query = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ACL {
        static instance: ACL = ACL {
            channel_id: ::std::option::Option::None,
            inherit_acls: ::std::option::Option::None,
            groups: ::std::vec::Vec::new(),
            acls: ::std::vec::Vec::new(),
            query: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ACL {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ACL").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ACL {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ACL {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ACL`
pub mod acl {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:MumbleProto.ACL.ChanGroup)
    pub struct ChanGroup {
        // message fields
        // @@protoc_insertion_point(field:MumbleProto.ACL.ChanGroup.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:MumbleProto.ACL.ChanGroup.inherited)
        pub inherited: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:MumbleProto.ACL.ChanGroup.inherit)
        pub inherit: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:MumbleProto.ACL.ChanGroup.inheritable)
        pub inheritable: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:MumbleProto.ACL.ChanGroup.add)
        pub add: ::std::vec::Vec<u32>,
        // @@protoc_insertion_point(field:MumbleProto.ACL.ChanGroup.remove)
        pub remove: ::std::vec::Vec<u32>,
        // @@protoc_insertion_point(field:MumbleProto.ACL.ChanGroup.inherited_members)
        pub inherited_members: ::std::vec::Vec<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:MumbleProto.ACL.ChanGroup.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ChanGroup {
        fn default() -> &'a ChanGroup {
            <ChanGroup as ::protobuf::Message>::default_instance()
        }
    }

    impl ChanGroup {
        pub fn new() -> ChanGroup {
            ::std::default::Default::default()
        }

        // required string name = 1;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bool inherited = 2;

        pub fn inherited(&self) -> bool {
            self.inherited.unwrap_or(true)
        }

        pub fn clear_inherited(&mut self) {
            self.inherited = ::std::option::Option::None;
        }

        pub fn has_inherited(&self) -> bool {
            self.inherited.is_some()
        }

        // Param is passed by value, moved
        pub fn set_inherited(&mut self, v: bool) {
            self.inherited = ::std::option::Option::Some(v);
        }

        // optional bool inherit = 3;

        pub fn inherit(&self) -> bool {
            self.inherit.unwrap_or(true)
        }

        pub fn clear_inherit(&mut self) {
            self.inherit = ::std::option::Option::None;
        }

        pub fn has_inherit(&self) -> bool {
            self.inherit.is_some()
        }

        // Param is passed by value, moved
        pub fn set_inherit(&mut self, v: bool) {
            self.inherit = ::std::option::Option::Some(v);
        }

        // optional bool inheritable = 4;

        pub fn inheritable(&self) -> bool {
            self.inheritable.unwrap_or(true)
        }

        pub fn clear_inheritable(&mut self) {
            self.inheritable = ::std::option::Option::None;
        }

        pub fn has_inheritable(&self) -> bool {
            self.inheritable.is_some()
        }

        // Param is passed by value, moved
        pub fn set_inheritable(&mut self, v: bool) {
            self.inheritable = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(7);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &ChanGroup| { &m.name },
                |m: &mut ChanGroup| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "inherited",
                |m: &ChanGroup| { &m.inherited },
                |m: &mut ChanGroup| { &mut m.inherited },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "inherit",
                |m: &ChanGroup| { &m.inherit },
                |m: &mut ChanGroup| { &mut m.inherit },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "inheritable",
                |m: &ChanGroup| { &m.inheritable },
                |m: &mut ChanGroup| { &mut m.inheritable },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "add",
                |m: &ChanGroup| { &m.add },
                |m: &mut ChanGroup| { &mut m.add },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "remove",
                |m: &ChanGroup| { &m.remove },
                |m: &mut ChanGroup| { &mut m.remove },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "inherited_members",
                |m: &ChanGroup| { &m.inherited_members },
                |m: &mut ChanGroup| { &mut m.inherited_members },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ChanGroup>(
                "ACL.ChanGroup",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ChanGroup {
        const NAME: &'static str = "ChanGroup";

        fn is_initialized(&self) -> bool {
            if self.name.is_none() {
                return false;
            }
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    16 => {
                        self.inherited = ::std::option::Option::Some(is.read_bool()?);
                    },
                    24 => {
                        self.inherit = ::std::option::Option::Some(is.read_bool()?);
                    },
                    32 => {
                        self.inheritable = ::std::option::Option::Some(is.read_bool()?);
                    },
                    42 => {
                        is.read_repeated_packed_uint32_into(&mut self.add)?;
                    },
                    40 => {
                        self.add.push(is.read_uint32()?);
                    },
                    50 => {
                        is.read_repeated_packed_uint32_into(&mut self.remove)?;
                    },
                    48 => {
                        self.remove.push(is.read_uint32()?);
                    },
                    58 => {
                        is.read_repeated_packed_uint32_into(&mut self.inherited_members)?;
                    },
                    56 => {
                        self.inherited_members.push(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.inherited {
                my_size += 1 + 1;
            }
            if let Some(v) = self.inherit {
                my_size += 1 + 1;
            }
            if let Some(v) = self.inheritable {
                my_size += 1 + 1;
            }
            for value in &self.add {
                my_size += ::protobuf::rt::uint32_size(5, *value);
            };
            for value in &self.remove {
                my_size += ::protobuf::rt::uint32_size(6, *value);
            };
            for value in &self.inherited_members {
                my_size += ::protobuf::rt::uint32_size(7, *value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.inherited {
                os.write_bool(2, v)?;
            }
            if let Some(v) = self.inherit {
                os.write_bool(3, v)?;
            }
            if let Some(v) = self.inheritable {
                os.write_bool(4, v)?;
            }
            for v in &self.add {
                os.write_uint32(5, *v)?;
            };
            for v in &self.remove {
                os.write_uint32(6, *v)?;
            };
            for v in &self.inherited_members {
                os.write_uint32(7, *v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ChanGroup {
            ChanGroup::new()
        }

        fn clear(&mut self) {
            self.name = ::std::option::Option::None;
            self.inherited = ::std::option::Option::None;
            self.inherit = ::std::option::Option::None;
            self.inheritable = ::std::option::Option::None;
            self.add.clear();
            self.remove.clear();
            self.inherited_members.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ChanGroup {
            static instance: ChanGroup = ChanGroup {
                name: ::std::option::Option::None,
                inherited: ::std::option::Option::None,
                inherit: ::std::option::Option::None,
                inheritable: ::std::option::Option::None,
                add: ::std::vec::Vec::new(),
                remove: ::std::vec::Vec::new(),
                inherited_members: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ChanGroup {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ACL.ChanGroup").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ChanGroup {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ChanGroup {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:MumbleProto.ACL.ChanACL)
    pub struct ChanACL {
        // message fields
        // @@protoc_insertion_point(field:MumbleProto.ACL.ChanACL.apply_here)
        pub apply_here: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:MumbleProto.ACL.ChanACL.apply_subs)
        pub apply_subs: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:MumbleProto.ACL.ChanACL.inherited)
        pub inherited: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:MumbleProto.ACL.ChanACL.user_id)
        pub user_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:MumbleProto.ACL.ChanACL.group)
        pub group: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:MumbleProto.ACL.ChanACL.grant)
        pub grant: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:MumbleProto.ACL.ChanACL.deny)
        pub deny: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:MumbleProto.ACL.ChanACL.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ChanACL {
        fn default() -> &'a ChanACL {
            <ChanACL as ::protobuf::Message>::default_instance()
        }
    }

    impl ChanACL {
        pub fn new() -> ChanACL {
            ::std::default::Default::default()
        }

        // optional bool apply_here = 1;

        pub fn apply_here(&self) -> bool {
            self.apply_here.unwrap_or(true)
        }

        pub fn clear_apply_here(&mut self) {
            self.apply_here = ::std::option::Option::None;
        }

        pub fn has_apply_here(&self) -> bool {
            self.apply_here.is_some()
        }

        // Param is passed by value, moved
        pub fn set_apply_here(&mut self, v: bool) {
            self.apply_here = ::std::option::Option::Some(v);
        }

        // optional bool apply_subs = 2;

        pub fn apply_subs(&self) -> bool {
            self.apply_subs.unwrap_or(true)
        }

        pub fn clear_apply_subs(&mut self) {
            self.apply_subs = ::std::option::Option::None;
        }

        pub fn has_apply_subs(&self) -> bool {
            self.apply_subs.is_some()
        }

        // Param is passed by value, moved
        pub fn set_apply_subs(&mut self, v: bool) {
            self.apply_subs = ::std::option::Option::Some(v);
        }

        // optional bool inherited = 3;

        pub fn inherited(&self) -> bool {
            self.inherited.unwrap_or(true)
        }

        pub fn clear_inherited(&mut self) {
            self.inherited = ::std::option::Option::None;
        }

        pub fn has_inherited(&self) -> bool {
            self.inherited.is_some()
        }

        // Param is passed by value, moved
        pub fn set_inherited(&mut self, v: bool) {
            self.inherited = ::std::option::Option::Some(v);
        }

        // optional uint32 user_id = 4;

        pub fn user_id(&self) -> u32 {
            self.user_id.unwrap_or(0)
        }

        pub fn clear_user_id(&mut self) {
            self.user_id = ::std::option::Option::None;
        }

        pub fn has_user_id(&self) -> bool {
            self.user_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_user_id(&mut self, v: u32) {
            self.user_id = ::std::option::Option::Some(v);
        }

        // optional string group = 5;

        pub fn group(&self) -> &str {
            match self.group.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_group(&mut self) {
            self.group = ::std::option::Option::None;
        }

        pub fn has_group(&self) -> bool {
            self.group.is_some()
        }

        // Param is passed by value, moved
        pub fn set_group(&mut self, v: ::std::string::String) {
            self.group = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_group(&mut self) -> &mut ::std::string::String {
            if self.group.is_none() {
                self.group = ::std::option::Option::Some(::std::string::String::new());
            }
            self.group.as_mut().unwrap()
        }

        // Take field
        pub fn take_group(&mut self) -> ::std::string::String {
            self.group.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 grant = 6;

        pub fn grant(&self) -> u32 {
            self.grant.unwrap_or(0)
        }

        pub fn clear_grant(&mut self) {
            self.grant = ::std::option::Option::None;
        }

        pub fn has_grant(&self) -> bool {
            self.grant.is_some()
        }

        // Param is passed by value, moved
        pub fn set_grant(&mut self, v: u32) {
            self.grant = ::std::option::Option::Some(v);
        }

        // optional uint32 deny = 7;

        pub fn deny(&self) -> u32 {
            self.deny.unwrap_or(0)
        }

        pub fn clear_deny(&mut self) {
            self.deny = ::std::option::Option::None;
        }

        pub fn has_deny(&self) -> bool {
            self.deny.is_some()
        }

        // Param is passed by value, moved
        pub fn set_deny(&mut self, v: u32) {
            self.deny = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(7);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "apply_here",
                |m: &ChanACL| { &m.apply_here },
                |m: &mut ChanACL| { &mut m.apply_here },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "apply_subs",
                |m: &ChanACL| { &m.apply_subs },
                |m: &mut ChanACL| { &mut m.apply_subs },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "inherited",
                |m: &ChanACL| { &m.inherited },
                |m: &mut ChanACL| { &mut m.inherited },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "user_id",
                |m: &ChanACL| { &m.user_id },
                |m: &mut ChanACL| { &mut m.user_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "group",
                |m: &ChanACL| { &m.group },
                |m: &mut ChanACL| { &mut m.group },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "grant",
                |m: &ChanACL| { &m.grant },
                |m: &mut ChanACL| { &mut m.grant },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "deny",
                |m: &ChanACL| { &m.deny },
                |m: &mut ChanACL| { &mut m.deny },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ChanACL>(
                "ACL.ChanACL",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ChanACL {
        const NAME: &'static str = "ChanACL";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.apply_here = ::std::option::Option::Some(is.read_bool()?);
                    },
                    16 => {
                        self.apply_subs = ::std::option::Option::Some(is.read_bool()?);
                    },
                    24 => {
                        self.inherited = ::std::option::Option::Some(is.read_bool()?);
                    },
                    32 => {
                        self.user_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    42 => {
                        self.group = ::std::option::Option::Some(is.read_string()?);
                    },
                    48 => {
                        self.grant = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.deny = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.apply_here {
                my_size += 1 + 1;
            }
            if let Some(v) = self.apply_subs {
                my_size += 1 + 1;
            }
            if let Some(v) = self.inherited {
                my_size += 1 + 1;
            }
            if let Some(v) = self.user_id {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.group.as_ref() {
                my_size += ::protobuf::rt::string_size(5, &v);
            }
            if let Some(v) = self.grant {
                my_size += ::protobuf::rt::uint32_size(6, v);
            }
            if let Some(v) = self.deny {
                my_size += ::protobuf::rt::uint32_size(7, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.apply_here {
                os.write_bool(1, v)?;
            }
            if let Some(v) = self.apply_subs {
                os.write_bool(2, v)?;
            }
            if let Some(v) = self.inherited {
                os.write_bool(3, v)?;
            }
            if let Some(v) = self.user_id {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.group.as_ref() {
                os.write_string(5, v)?;
            }
            if let Some(v) = self.grant {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.deny {
                os.write_uint32(7, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ChanACL {
            ChanACL::new()
        }

        fn clear(&mut self) {
            self.apply_here = ::std::option::Option::None;
            self.apply_subs = ::std::option::Option::None;
            self.inherited = ::std::option::Option::None;
            self.user_id = ::std::option::Option::None;
            self.group = ::std::option::Option::None;
            self.grant = ::std::option::Option::None;
            self.deny = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ChanACL {
            static instance: ChanACL = ChanACL {
                apply_here: ::std::option::Option::None,
                apply_subs: ::std::option::Option::None,
                inherited: ::std::option::Option::None,
                user_id: ::std::option::Option::None,
                group: ::std::option::Option::None,
                grant: ::std::option::Option::None,
                deny: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ChanACL {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ACL.ChanACL").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ChanACL {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ChanACL {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:MumbleProto.QueryUsers)
pub struct QueryUsers {
    // message fields
    // @@protoc_insertion_point(field:MumbleProto.QueryUsers.ids)
    pub ids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:MumbleProto.QueryUsers.names)
    pub names: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:MumbleProto.QueryUsers.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryUsers {
    fn default() -> &'a QueryUsers {
        <QueryUsers as ::protobuf::Message>::default_instance()
    }
}

impl QueryUsers {
    pub fn new() -> QueryUsers {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &QueryUsers| { &m.ids },
            |m: &mut QueryUsers| { &mut m.ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "names",
            |m: &QueryUsers| { &m.names },
            |m: &mut QueryUsers| { &mut m.names },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryUsers>(
            "QueryUsers",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryUsers {
    const NAME: &'static str = "QueryUsers";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.ids)?;
                },
                8 => {
                    self.ids.push(is.read_uint32()?);
                },
                18 => {
                    self.names.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.ids {
            my_size += ::protobuf::rt::uint32_size(1, *value);
        };
        for value in &self.names {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.ids {
            os.write_uint32(1, *v)?;
        };
        for v in &self.names {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryUsers {
        QueryUsers::new()
    }

    fn clear(&mut self) {
        self.ids.clear();
        self.names.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryUsers {
        static instance: QueryUsers = QueryUsers {
            ids: ::std::vec::Vec::new(),
            names: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryUsers {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryUsers").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryUsers {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryUsers {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:MumbleProto.CryptSetup)
pub struct CryptSetup {
    // message fields
    // @@protoc_insertion_point(field:MumbleProto.CryptSetup.key)
    pub key: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:MumbleProto.CryptSetup.client_nonce)
    pub client_nonce: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:MumbleProto.CryptSetup.server_nonce)
    pub server_nonce: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:MumbleProto.CryptSetup.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CryptSetup {
    fn default() -> &'a CryptSetup {
        <CryptSetup as ::protobuf::Message>::default_instance()
    }
}

impl CryptSetup {
    pub fn new() -> CryptSetup {
        ::std::default::Default::default()
    }

    // optional bytes key = 1;

    pub fn key(&self) -> &[u8] {
        match self.key.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_key(&mut self) {
        self.key = ::std::option::Option::None;
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.key.is_none() {
            self.key = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
        self.key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes client_nonce = 2;

    pub fn client_nonce(&self) -> &[u8] {
        match self.client_nonce.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_client_nonce(&mut self) {
        self.client_nonce = ::std::option::Option::None;
    }

    pub fn has_client_nonce(&self) -> bool {
        self.client_nonce.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_nonce(&mut self, v: ::std::vec::Vec<u8>) {
        self.client_nonce = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client_nonce(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.client_nonce.is_none() {
            self.client_nonce = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.client_nonce.as_mut().unwrap()
    }

    // Take field
    pub fn take_client_nonce(&mut self) -> ::std::vec::Vec<u8> {
        self.client_nonce.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes server_nonce = 3;

    pub fn server_nonce(&self) -> &[u8] {
        match self.server_nonce.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_server_nonce(&mut self) {
        self.server_nonce = ::std::option::Option::None;
    }

    pub fn has_server_nonce(&self) -> bool {
        self.server_nonce.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_nonce(&mut self, v: ::std::vec::Vec<u8>) {
        self.server_nonce = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server_nonce(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.server_nonce.is_none() {
            self.server_nonce = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.server_nonce.as_mut().unwrap()
    }

    // Take field
    pub fn take_server_nonce(&mut self) -> ::std::vec::Vec<u8> {
        self.server_nonce.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "key",
            |m: &CryptSetup| { &m.key },
            |m: &mut CryptSetup| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_nonce",
            |m: &CryptSetup| { &m.client_nonce },
            |m: &mut CryptSetup| { &mut m.client_nonce },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_nonce",
            |m: &CryptSetup| { &m.server_nonce },
            |m: &mut CryptSetup| { &mut m.server_nonce },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CryptSetup>(
            "CryptSetup",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CryptSetup {
    const NAME: &'static str = "CryptSetup";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.client_nonce = ::std::option::Option::Some(is.read_bytes()?);
                },
                26 => {
                    self.server_nonce = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.client_nonce.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.server_nonce.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.key.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.client_nonce.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.server_nonce.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CryptSetup {
        CryptSetup::new()
    }

    fn clear(&mut self) {
        self.key = ::std::option::Option::None;
        self.client_nonce = ::std::option::Option::None;
        self.server_nonce = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CryptSetup {
        static instance: CryptSetup = CryptSetup {
            key: ::std::option::Option::None,
            client_nonce: ::std::option::Option::None,
            server_nonce: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CryptSetup {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CryptSetup").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CryptSetup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CryptSetup {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:MumbleProto.ContextActionModify)
pub struct ContextActionModify {
    // message fields
    // @@protoc_insertion_point(field:MumbleProto.ContextActionModify.action)
    pub action: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:MumbleProto.ContextActionModify.text)
    pub text: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:MumbleProto.ContextActionModify.context)
    pub context: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:MumbleProto.ContextActionModify.operation)
    pub operation: ::std::option::Option<::protobuf::EnumOrUnknown<context_action_modify::Operation>>,
    // special fields
    // @@protoc_insertion_point(special_field:MumbleProto.ContextActionModify.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ContextActionModify {
    fn default() -> &'a ContextActionModify {
        <ContextActionModify as ::protobuf::Message>::default_instance()
    }
}

impl ContextActionModify {
    pub fn new() -> ContextActionModify {
        ::std::default::Default::default()
    }

    // required string action = 1;

    pub fn action(&self) -> &str {
        match self.action.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_action(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action(&self) -> bool {
        self.action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: ::std::string::String) {
        self.action = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action(&mut self) -> &mut ::std::string::String {
        if self.action.is_none() {
            self.action = ::std::option::Option::Some(::std::string::String::new());
        }
        self.action.as_mut().unwrap()
    }

    // Take field
    pub fn take_action(&mut self) -> ::std::string::String {
        self.action.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string text = 2;

    pub fn text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 context = 3;

    pub fn context(&self) -> u32 {
        self.context.unwrap_or(0)
    }

    pub fn clear_context(&mut self) {
        self.context = ::std::option::Option::None;
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: u32) {
        self.context = ::std::option::Option::Some(v);
    }

    // optional .MumbleProto.ContextActionModify.Operation operation = 4;

    pub fn operation(&self) -> context_action_modify::Operation {
        match self.operation {
            Some(e) => e.enum_value_or(context_action_modify::Operation::Add),
            None => context_action_modify::Operation::Add,
        }
    }

    pub fn clear_operation(&mut self) {
        self.operation = ::std::option::Option::None;
    }

    pub fn has_operation(&self) -> bool {
        self.operation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_operation(&mut self, v: context_action_modify::Operation) {
        self.operation = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "action",
            |m: &ContextActionModify| { &m.action },
            |m: &mut ContextActionModify| { &mut m.action },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "text",
            |m: &ContextActionModify| { &m.text },
            |m: &mut ContextActionModify| { &mut m.text },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "context",
            |m: &ContextActionModify| { &m.context },
            |m: &mut ContextActionModify| { &mut m.context },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "operation",
            |m: &ContextActionModify| { &m.operation },
            |m: &mut ContextActionModify| { &mut m.operation },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ContextActionModify>(
            "ContextActionModify",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ContextActionModify {
    const NAME: &'static str = "ContextActionModify";

    fn is_initialized(&self) -> bool {
        if self.action.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.action = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.text = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.context = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.operation = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.action.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.context {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.operation {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.action.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.text.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.context {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.operation {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ContextActionModify {
        ContextActionModify::new()
    }

    fn clear(&mut self) {
        self.action = ::std::option::Option::None;
        self.text = ::std::option::Option::None;
        self.context = ::std::option::Option::None;
        self.operation = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ContextActionModify {
        static instance: ContextActionModify = ContextActionModify {
            action: ::std::option::Option::None,
            text: ::std::option::Option::None,
            context: ::std::option::Option::None,
            operation: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ContextActionModify {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ContextActionModify").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ContextActionModify {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContextActionModify {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ContextActionModify`
pub mod context_action_modify {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:MumbleProto.ContextActionModify.Context)
    pub enum Context {
        // @@protoc_insertion_point(enum_value:MumbleProto.ContextActionModify.Context.Server)
        Server = 1,
        // @@protoc_insertion_point(enum_value:MumbleProto.ContextActionModify.Context.Channel)
        Channel = 2,
        // @@protoc_insertion_point(enum_value:MumbleProto.ContextActionModify.Context.User)
        User = 4,
    }

    impl ::protobuf::Enum for Context {
        const NAME: &'static str = "Context";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Context> {
            match value {
                1 => ::std::option::Option::Some(Context::Server),
                2 => ::std::option::Option::Some(Context::Channel),
                4 => ::std::option::Option::Some(Context::User),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Context] = &[
            Context::Server,
            Context::Channel,
            Context::User,
        ];
    }

    impl ::protobuf::EnumFull for Context {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("ContextActionModify.Context").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                Context::Server => 0,
                Context::Channel => 1,
                Context::User => 2,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for Context {
        fn default() -> Self {
            Context::Server
        }
    }

    impl Context {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Context>("ContextActionModify.Context")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:MumbleProto.ContextActionModify.Operation)
    pub enum Operation {
        // @@protoc_insertion_point(enum_value:MumbleProto.ContextActionModify.Operation.Add)
        Add = 0,
        // @@protoc_insertion_point(enum_value:MumbleProto.ContextActionModify.Operation.Remove)
        Remove = 1,
    }

    impl ::protobuf::Enum for Operation {
        const NAME: &'static str = "Operation";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Operation> {
            match value {
                0 => ::std::option::Option::Some(Operation::Add),
                1 => ::std::option::Option::Some(Operation::Remove),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Operation] = &[
            Operation::Add,
            Operation::Remove,
        ];
    }

    impl ::protobuf::EnumFull for Operation {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("ContextActionModify.Operation").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Operation {
        fn default() -> Self {
            Operation::Add
        }
    }

    impl Operation {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Operation>("ContextActionModify.Operation")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:MumbleProto.ContextAction)
pub struct ContextAction {
    // message fields
    // @@protoc_insertion_point(field:MumbleProto.ContextAction.session)
    pub session: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:MumbleProto.ContextAction.channel_id)
    pub channel_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:MumbleProto.ContextAction.action)
    pub action: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:MumbleProto.ContextAction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ContextAction {
    fn default() -> &'a ContextAction {
        <ContextAction as ::protobuf::Message>::default_instance()
    }
}

impl ContextAction {
    pub fn new() -> ContextAction {
        ::std::default::Default::default()
    }

    // optional uint32 session = 1;

    pub fn session(&self) -> u32 {
        self.session.unwrap_or(0)
    }

    pub fn clear_session(&mut self) {
        self.session = ::std::option::Option::None;
    }

    pub fn has_session(&self) -> bool {
        self.session.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session(&mut self, v: u32) {
        self.session = ::std::option::Option::Some(v);
    }

    // optional uint32 channel_id = 2;

    pub fn channel_id(&self) -> u32 {
        self.channel_id.unwrap_or(0)
    }

    pub fn clear_channel_id(&mut self) {
        self.channel_id = ::std::option::Option::None;
    }

    pub fn has_channel_id(&self) -> bool {
        self.channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel_id(&mut self, v: u32) {
        self.channel_id = ::std::option::Option::Some(v);
    }

    // required string action = 3;

    pub fn action(&self) -> &str {
        match self.action.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_action(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action(&self) -> bool {
        self.action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: ::std::string::String) {
        self.action = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action(&mut self) -> &mut ::std::string::String {
        if self.action.is_none() {
            self.action = ::std::option::Option::Some(::std::string::String::new());
        }
        self.action.as_mut().unwrap()
    }

    // Take field
    pub fn take_action(&mut self) -> ::std::string::String {
        self.action.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "session",
            |m: &ContextAction| { &m.session },
            |m: &mut ContextAction| { &mut m.session },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "channel_id",
            |m: &ContextAction| { &m.channel_id },
            |m: &mut ContextAction| { &mut m.channel_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "action",
            |m: &ContextAction| { &m.action },
            |m: &mut ContextAction| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ContextAction>(
            "ContextAction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ContextAction {
    const NAME: &'static str = "ContextAction";

    fn is_initialized(&self) -> bool {
        if self.action.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.session = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.channel_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.action = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.session {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.channel_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.action.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.session {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.channel_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.action.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ContextAction {
        ContextAction::new()
    }

    fn clear(&mut self) {
        self.session = ::std::option::Option::None;
        self.channel_id = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ContextAction {
        static instance: ContextAction = ContextAction {
            session: ::std::option::Option::None,
            channel_id: ::std::option::Option::None,
            action: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ContextAction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ContextAction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ContextAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContextAction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:MumbleProto.UserList)
pub struct UserList {
    // message fields
    // @@protoc_insertion_point(field:MumbleProto.UserList.users)
    pub users: ::std::vec::Vec<user_list::User>,
    // special fields
    // @@protoc_insertion_point(special_field:MumbleProto.UserList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UserList {
    fn default() -> &'a UserList {
        <UserList as ::protobuf::Message>::default_instance()
    }
}

impl UserList {
    pub fn new() -> UserList {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "users",
            |m: &UserList| { &m.users },
            |m: &mut UserList| { &mut m.users },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserList>(
            "UserList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UserList {
    const NAME: &'static str = "UserList";

    fn is_initialized(&self) -> bool {
        for v in &self.users {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.users.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.users {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.users {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UserList {
        UserList::new()
    }

    fn clear(&mut self) {
        self.users.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UserList {
        static instance: UserList = UserList {
            users: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UserList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UserList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UserList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `UserList`
pub mod user_list {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:MumbleProto.UserList.User)
    pub struct User {
        // message fields
        // @@protoc_insertion_point(field:MumbleProto.UserList.User.user_id)
        pub user_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:MumbleProto.UserList.User.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:MumbleProto.UserList.User.last_seen)
        pub last_seen: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:MumbleProto.UserList.User.last_channel)
        pub last_channel: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:MumbleProto.UserList.User.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a User {
        fn default() -> &'a User {
            <User as ::protobuf::Message>::default_instance()
        }
    }

    impl User {
        pub fn new() -> User {
            ::std::default::Default::default()
        }

        // required uint32 user_id = 1;

        pub fn user_id(&self) -> u32 {
            self.user_id.unwrap_or(0)
        }

        pub fn clear_user_id(&mut self) {
            self.user_id = ::std::option::Option::None;
        }

        pub fn has_user_id(&self) -> bool {
            self.user_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_user_id(&mut self, v: u32) {
            self.user_id = ::std::option::Option::Some(v);
        }

        // optional string name = 2;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string last_seen = 3;

        pub fn last_seen(&self) -> &str {
            match self.last_seen.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_last_seen(&mut self) {
            self.last_seen = ::std::option::Option::None;
        }

        pub fn has_last_seen(&self) -> bool {
            self.last_seen.is_some()
        }

        // Param is passed by value, moved
        pub fn set_last_seen(&mut self, v: ::std::string::String) {
            self.last_seen = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_last_seen(&mut self) -> &mut ::std::string::String {
            if self.last_seen.is_none() {
                self.last_seen = ::std::option::Option::Some(::std::string::String::new());
            }
            self.last_seen.as_mut().unwrap()
        }

        // Take field
        pub fn take_last_seen(&mut self) -> ::std::string::String {
            self.last_seen.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 last_channel = 4;

        pub fn last_channel(&self) -> u32 {
            self.last_channel.unwrap_or(0)
        }

        pub fn clear_last_channel(&mut self) {
            self.last_channel = ::std::option::Option::None;
        }

        pub fn has_last_channel(&self) -> bool {
            self.last_channel.is_some()
        }

        // Param is passed by value, moved
        pub fn set_last_channel(&mut self, v: u32) {
            self.last_channel = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "user_id",
                |m: &User| { &m.user_id },
                |m: &mut User| { &mut m.user_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &User| { &m.name },
                |m: &mut User| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "last_seen",
                |m: &User| { &m.last_seen },
                |m: &mut User| { &mut m.last_seen },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "last_channel",
                |m: &User| { &m.last_channel },
                |m: &mut User| { &mut m.last_channel },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<User>(
                "UserList.User",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for User {
        const NAME: &'static str = "User";

        fn is_initialized(&self) -> bool {
            if self.user_id.is_none() {
                return false;
            }
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.user_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    26 => {
                        self.last_seen = ::std::option::Option::Some(is.read_string()?);
                    },
                    32 => {
                        self.last_channel = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.user_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.last_seen.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.last_channel {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.user_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.last_seen.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.last_channel {
                os.write_uint32(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> User {
            User::new()
        }

        fn clear(&mut self) {
            self.user_id = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.last_seen = ::std::option::Option::None;
            self.last_channel = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static User {
            static instance: User = User {
                user_id: ::std::option::Option::None,
                name: ::std::option::Option::None,
                last_seen: ::std::option::Option::None,
                last_channel: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for User {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("UserList.User").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for User {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for User {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:MumbleProto.VoiceTarget)
pub struct VoiceTarget {
    // message fields
    // @@protoc_insertion_point(field:MumbleProto.VoiceTarget.id)
    pub id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:MumbleProto.VoiceTarget.targets)
    pub targets: ::std::vec::Vec<voice_target::Target>,
    // special fields
    // @@protoc_insertion_point(special_field:MumbleProto.VoiceTarget.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VoiceTarget {
    fn default() -> &'a VoiceTarget {
        <VoiceTarget as ::protobuf::Message>::default_instance()
    }
}

impl VoiceTarget {
    pub fn new() -> VoiceTarget {
        ::std::default::Default::default()
    }

    // optional uint32 id = 1;

    pub fn id(&self) -> u32 {
        self.id.unwrap_or(0)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &VoiceTarget| { &m.id },
            |m: &mut VoiceTarget| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "targets",
            |m: &VoiceTarget| { &m.targets },
            |m: &mut VoiceTarget| { &mut m.targets },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VoiceTarget>(
            "VoiceTarget",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VoiceTarget {
    const NAME: &'static str = "VoiceTarget";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.targets.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.targets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id {
            os.write_uint32(1, v)?;
        }
        for v in &self.targets {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VoiceTarget {
        VoiceTarget::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.targets.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VoiceTarget {
        static instance: VoiceTarget = VoiceTarget {
            id: ::std::option::Option::None,
            targets: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VoiceTarget {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VoiceTarget").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VoiceTarget {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VoiceTarget {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `VoiceTarget`
pub mod voice_target {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:MumbleProto.VoiceTarget.Target)
    pub struct Target {
        // message fields
        // @@protoc_insertion_point(field:MumbleProto.VoiceTarget.Target.session)
        pub session: ::std::vec::Vec<u32>,
        // @@protoc_insertion_point(field:MumbleProto.VoiceTarget.Target.channel_id)
        pub channel_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:MumbleProto.VoiceTarget.Target.group)
        pub group: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:MumbleProto.VoiceTarget.Target.links)
        pub links: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:MumbleProto.VoiceTarget.Target.children)
        pub children: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:MumbleProto.VoiceTarget.Target.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Target {
        fn default() -> &'a Target {
            <Target as ::protobuf::Message>::default_instance()
        }
    }

    impl Target {
        pub fn new() -> Target {
            ::std::default::Default::default()
        }

        // optional uint32 channel_id = 2;

        pub fn channel_id(&self) -> u32 {
            self.channel_id.unwrap_or(0)
        }

        pub fn clear_channel_id(&mut self) {
            self.channel_id = ::std::option::Option::None;
        }

        pub fn has_channel_id(&self) -> bool {
            self.channel_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_channel_id(&mut self, v: u32) {
            self.channel_id = ::std::option::Option::Some(v);
        }

        // optional string group = 3;

        pub fn group(&self) -> &str {
            match self.group.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_group(&mut self) {
            self.group = ::std::option::Option::None;
        }

        pub fn has_group(&self) -> bool {
            self.group.is_some()
        }

        // Param is passed by value, moved
        pub fn set_group(&mut self, v: ::std::string::String) {
            self.group = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_group(&mut self) -> &mut ::std::string::String {
            if self.group.is_none() {
                self.group = ::std::option::Option::Some(::std::string::String::new());
            }
            self.group.as_mut().unwrap()
        }

        // Take field
        pub fn take_group(&mut self) -> ::std::string::String {
            self.group.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bool links = 4;

        pub fn links(&self) -> bool {
            self.links.unwrap_or(false)
        }

        pub fn clear_links(&mut self) {
            self.links = ::std::option::Option::None;
        }

        pub fn has_links(&self) -> bool {
            self.links.is_some()
        }

        // Param is passed by value, moved
        pub fn set_links(&mut self, v: bool) {
            self.links = ::std::option::Option::Some(v);
        }

        // optional bool children = 5;

        pub fn children(&self) -> bool {
            self.children.unwrap_or(false)
        }

        pub fn clear_children(&mut self) {
            self.children = ::std::option::Option::None;
        }

        pub fn has_children(&self) -> bool {
            self.children.is_some()
        }

        // Param is passed by value, moved
        pub fn set_children(&mut self, v: bool) {
            self.children = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "session",
                |m: &Target| { &m.session },
                |m: &mut Target| { &mut m.session },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "channel_id",
                |m: &Target| { &m.channel_id },
                |m: &mut Target| { &mut m.channel_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "group",
                |m: &Target| { &m.group },
                |m: &mut Target| { &mut m.group },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "links",
                |m: &Target| { &m.links },
                |m: &mut Target| { &mut m.links },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "children",
                |m: &Target| { &m.children },
                |m: &mut Target| { &mut m.children },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Target>(
                "VoiceTarget.Target",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Target {
        const NAME: &'static str = "Target";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        is.read_repeated_packed_uint32_into(&mut self.session)?;
                    },
                    8 => {
                        self.session.push(is.read_uint32()?);
                    },
                    16 => {
                        self.channel_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    26 => {
                        self.group = ::std::option::Option::Some(is.read_string()?);
                    },
                    32 => {
                        self.links = ::std::option::Option::Some(is.read_bool()?);
                    },
                    40 => {
                        self.children = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.session {
                my_size += ::protobuf::rt::uint32_size(1, *value);
            };
            if let Some(v) = self.channel_id {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.group.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.links {
                my_size += 1 + 1;
            }
            if let Some(v) = self.children {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.session {
                os.write_uint32(1, *v)?;
            };
            if let Some(v) = self.channel_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.group.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.links {
                os.write_bool(4, v)?;
            }
            if let Some(v) = self.children {
                os.write_bool(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Target {
            Target::new()
        }

        fn clear(&mut self) {
            self.session.clear();
            self.channel_id = ::std::option::Option::None;
            self.group = ::std::option::Option::None;
            self.links = ::std::option::Option::None;
            self.children = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Target {
            static instance: Target = Target {
                session: ::std::vec::Vec::new(),
                channel_id: ::std::option::Option::None,
                group: ::std::option::Option::None,
                links: ::std::option::Option::None,
                children: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Target {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("VoiceTarget.Target").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Target {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Target {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:MumbleProto.PermissionQuery)
pub struct PermissionQuery {
    // message fields
    // @@protoc_insertion_point(field:MumbleProto.PermissionQuery.channel_id)
    pub channel_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:MumbleProto.PermissionQuery.permissions)
    pub permissions: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:MumbleProto.PermissionQuery.flush)
    pub flush: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:MumbleProto.PermissionQuery.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PermissionQuery {
    fn default() -> &'a PermissionQuery {
        <PermissionQuery as ::protobuf::Message>::default_instance()
    }
}

impl PermissionQuery {
    pub fn new() -> PermissionQuery {
        ::std::default::Default::default()
    }

    // optional uint32 channel_id = 1;

    pub fn channel_id(&self) -> u32 {
        self.channel_id.unwrap_or(0)
    }

    pub fn clear_channel_id(&mut self) {
        self.channel_id = ::std::option::Option::None;
    }

    pub fn has_channel_id(&self) -> bool {
        self.channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel_id(&mut self, v: u32) {
        self.channel_id = ::std::option::Option::Some(v);
    }

    // optional uint32 permissions = 2;

    pub fn permissions(&self) -> u32 {
        self.permissions.unwrap_or(0)
    }

    pub fn clear_permissions(&mut self) {
        self.permissions = ::std::option::Option::None;
    }

    pub fn has_permissions(&self) -> bool {
        self.permissions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_permissions(&mut self, v: u32) {
        self.permissions = ::std::option::Option::Some(v);
    }

    // optional bool flush = 3;

    pub fn flush(&self) -> bool {
        self.flush.unwrap_or(false)
    }

    pub fn clear_flush(&mut self) {
        self.flush = ::std::option::Option::None;
    }

    pub fn has_flush(&self) -> bool {
        self.flush.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flush(&mut self, v: bool) {
        self.flush = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "channel_id",
            |m: &PermissionQuery| { &m.channel_id },
            |m: &mut PermissionQuery| { &mut m.channel_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "permissions",
            |m: &PermissionQuery| { &m.permissions },
            |m: &mut PermissionQuery| { &mut m.permissions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "flush",
            |m: &PermissionQuery| { &m.flush },
            |m: &mut PermissionQuery| { &mut m.flush },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PermissionQuery>(
            "PermissionQuery",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PermissionQuery {
    const NAME: &'static str = "PermissionQuery";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.channel_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.permissions = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.flush = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.channel_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.permissions {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.flush {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.channel_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.permissions {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.flush {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PermissionQuery {
        PermissionQuery::new()
    }

    fn clear(&mut self) {
        self.channel_id = ::std::option::Option::None;
        self.permissions = ::std::option::Option::None;
        self.flush = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PermissionQuery {
        static instance: PermissionQuery = PermissionQuery {
            channel_id: ::std::option::Option::None,
            permissions: ::std::option::Option::None,
            flush: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PermissionQuery {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PermissionQuery").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PermissionQuery {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PermissionQuery {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:MumbleProto.CodecVersion)
pub struct CodecVersion {
    // message fields
    // @@protoc_insertion_point(field:MumbleProto.CodecVersion.alpha)
    pub alpha: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:MumbleProto.CodecVersion.beta)
    pub beta: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:MumbleProto.CodecVersion.prefer_alpha)
    pub prefer_alpha: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:MumbleProto.CodecVersion.opus)
    pub opus: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:MumbleProto.CodecVersion.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CodecVersion {
    fn default() -> &'a CodecVersion {
        <CodecVersion as ::protobuf::Message>::default_instance()
    }
}

impl CodecVersion {
    pub fn new() -> CodecVersion {
        ::std::default::Default::default()
    }

    // required int32 alpha = 1;

    pub fn alpha(&self) -> i32 {
        self.alpha.unwrap_or(0)
    }

    pub fn clear_alpha(&mut self) {
        self.alpha = ::std::option::Option::None;
    }

    pub fn has_alpha(&self) -> bool {
        self.alpha.is_some()
    }

    // Param is passed by value, moved
    pub fn set_alpha(&mut self, v: i32) {
        self.alpha = ::std::option::Option::Some(v);
    }

    // required int32 beta = 2;

    pub fn beta(&self) -> i32 {
        self.beta.unwrap_or(0)
    }

    pub fn clear_beta(&mut self) {
        self.beta = ::std::option::Option::None;
    }

    pub fn has_beta(&self) -> bool {
        self.beta.is_some()
    }

    // Param is passed by value, moved
    pub fn set_beta(&mut self, v: i32) {
        self.beta = ::std::option::Option::Some(v);
    }

    // required bool prefer_alpha = 3;

    pub fn prefer_alpha(&self) -> bool {
        self.prefer_alpha.unwrap_or(true)
    }

    pub fn clear_prefer_alpha(&mut self) {
        self.prefer_alpha = ::std::option::Option::None;
    }

    pub fn has_prefer_alpha(&self) -> bool {
        self.prefer_alpha.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prefer_alpha(&mut self, v: bool) {
        self.prefer_alpha = ::std::option::Option::Some(v);
    }

    // optional bool opus = 4;

    pub fn opus(&self) -> bool {
        self.opus.unwrap_or(false)
    }

    pub fn clear_opus(&mut self) {
        self.opus = ::std::option::Option::None;
    }

    pub fn has_opus(&self) -> bool {
        self.opus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_opus(&mut self, v: bool) {
        self.opus = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "alpha",
            |m: &CodecVersion| { &m.alpha },
            |m: &mut CodecVersion| { &mut m.alpha },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "beta",
            |m: &CodecVersion| { &m.beta },
            |m: &mut CodecVersion| { &mut m.beta },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "prefer_alpha",
            |m: &CodecVersion| { &m.prefer_alpha },
            |m: &mut CodecVersion| { &mut m.prefer_alpha },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "opus",
            |m: &CodecVersion| { &m.opus },
            |m: &mut CodecVersion| { &mut m.opus },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CodecVersion>(
            "CodecVersion",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CodecVersion {
    const NAME: &'static str = "CodecVersion";

    fn is_initialized(&self) -> bool {
        if self.alpha.is_none() {
            return false;
        }
        if self.beta.is_none() {
            return false;
        }
        if self.prefer_alpha.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.alpha = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.beta = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.prefer_alpha = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.opus = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.alpha {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.beta {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.prefer_alpha {
            my_size += 1 + 1;
        }
        if let Some(v) = self.opus {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.alpha {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.beta {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.prefer_alpha {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.opus {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CodecVersion {
        CodecVersion::new()
    }

    fn clear(&mut self) {
        self.alpha = ::std::option::Option::None;
        self.beta = ::std::option::Option::None;
        self.prefer_alpha = ::std::option::Option::None;
        self.opus = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CodecVersion {
        static instance: CodecVersion = CodecVersion {
            alpha: ::std::option::Option::None,
            beta: ::std::option::Option::None,
            prefer_alpha: ::std::option::Option::None,
            opus: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CodecVersion {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CodecVersion").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CodecVersion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CodecVersion {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:MumbleProto.UserStats)
pub struct UserStats {
    // message fields
    // @@protoc_insertion_point(field:MumbleProto.UserStats.session)
    pub session: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:MumbleProto.UserStats.stats_only)
    pub stats_only: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:MumbleProto.UserStats.certificates)
    pub certificates: ::std::vec::Vec<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:MumbleProto.UserStats.from_client)
    pub from_client: ::protobuf::MessageField<user_stats::Stats>,
    // @@protoc_insertion_point(field:MumbleProto.UserStats.from_server)
    pub from_server: ::protobuf::MessageField<user_stats::Stats>,
    // @@protoc_insertion_point(field:MumbleProto.UserStats.udp_packets)
    pub udp_packets: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:MumbleProto.UserStats.tcp_packets)
    pub tcp_packets: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:MumbleProto.UserStats.udp_ping_avg)
    pub udp_ping_avg: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:MumbleProto.UserStats.udp_ping_var)
    pub udp_ping_var: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:MumbleProto.UserStats.tcp_ping_avg)
    pub tcp_ping_avg: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:MumbleProto.UserStats.tcp_ping_var)
    pub tcp_ping_var: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:MumbleProto.UserStats.version)
    pub version: ::protobuf::MessageField<Version>,
    // @@protoc_insertion_point(field:MumbleProto.UserStats.celt_versions)
    pub celt_versions: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:MumbleProto.UserStats.address)
    pub address: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:MumbleProto.UserStats.bandwidth)
    pub bandwidth: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:MumbleProto.UserStats.onlinesecs)
    pub onlinesecs: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:MumbleProto.UserStats.idlesecs)
    pub idlesecs: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:MumbleProto.UserStats.strong_certificate)
    pub strong_certificate: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:MumbleProto.UserStats.opus)
    pub opus: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:MumbleProto.UserStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UserStats {
    fn default() -> &'a UserStats {
        <UserStats as ::protobuf::Message>::default_instance()
    }
}

impl UserStats {
    pub fn new() -> UserStats {
        ::std::default::Default::default()
    }

    // optional uint32 session = 1;

    pub fn session(&self) -> u32 {
        self.session.unwrap_or(0)
    }

    pub fn clear_session(&mut self) {
        self.session = ::std::option::Option::None;
    }

    pub fn has_session(&self) -> bool {
        self.session.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session(&mut self, v: u32) {
        self.session = ::std::option::Option::Some(v);
    }

    // optional bool stats_only = 2;

    pub fn stats_only(&self) -> bool {
        self.stats_only.unwrap_or(false)
    }

    pub fn clear_stats_only(&mut self) {
        self.stats_only = ::std::option::Option::None;
    }

    pub fn has_stats_only(&self) -> bool {
        self.stats_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stats_only(&mut self, v: bool) {
        self.stats_only = ::std::option::Option::Some(v);
    }

    // optional uint32 udp_packets = 6;

    pub fn udp_packets(&self) -> u32 {
        self.udp_packets.unwrap_or(0)
    }

    pub fn clear_udp_packets(&mut self) {
        self.udp_packets = ::std::option::Option::None;
    }

    pub fn has_udp_packets(&self) -> bool {
        self.udp_packets.is_some()
    }

    // Param is passed by value, moved
    pub fn set_udp_packets(&mut self, v: u32) {
        self.udp_packets = ::std::option::Option::Some(v);
    }

    // optional uint32 tcp_packets = 7;

    pub fn tcp_packets(&self) -> u32 {
        self.tcp_packets.unwrap_or(0)
    }

    pub fn clear_tcp_packets(&mut self) {
        self.tcp_packets = ::std::option::Option::None;
    }

    pub fn has_tcp_packets(&self) -> bool {
        self.tcp_packets.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tcp_packets(&mut self, v: u32) {
        self.tcp_packets = ::std::option::Option::Some(v);
    }

    // optional float udp_ping_avg = 8;

    pub fn udp_ping_avg(&self) -> f32 {
        self.udp_ping_avg.unwrap_or(0.)
    }

    pub fn clear_udp_ping_avg(&mut self) {
        self.udp_ping_avg = ::std::option::Option::None;
    }

    pub fn has_udp_ping_avg(&self) -> bool {
        self.udp_ping_avg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_udp_ping_avg(&mut self, v: f32) {
        self.udp_ping_avg = ::std::option::Option::Some(v);
    }

    // optional float udp_ping_var = 9;

    pub fn udp_ping_var(&self) -> f32 {
        self.udp_ping_var.unwrap_or(0.)
    }

    pub fn clear_udp_ping_var(&mut self) {
        self.udp_ping_var = ::std::option::Option::None;
    }

    pub fn has_udp_ping_var(&self) -> bool {
        self.udp_ping_var.is_some()
    }

    // Param is passed by value, moved
    pub fn set_udp_ping_var(&mut self, v: f32) {
        self.udp_ping_var = ::std::option::Option::Some(v);
    }

    // optional float tcp_ping_avg = 10;

    pub fn tcp_ping_avg(&self) -> f32 {
        self.tcp_ping_avg.unwrap_or(0.)
    }

    pub fn clear_tcp_ping_avg(&mut self) {
        self.tcp_ping_avg = ::std::option::Option::None;
    }

    pub fn has_tcp_ping_avg(&self) -> bool {
        self.tcp_ping_avg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tcp_ping_avg(&mut self, v: f32) {
        self.tcp_ping_avg = ::std::option::Option::Some(v);
    }

    // optional float tcp_ping_var = 11;

    pub fn tcp_ping_var(&self) -> f32 {
        self.tcp_ping_var.unwrap_or(0.)
    }

    pub fn clear_tcp_ping_var(&mut self) {
        self.tcp_ping_var = ::std::option::Option::None;
    }

    pub fn has_tcp_ping_var(&self) -> bool {
        self.tcp_ping_var.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tcp_ping_var(&mut self, v: f32) {
        self.tcp_ping_var = ::std::option::Option::Some(v);
    }

    // optional bytes address = 14;

    pub fn address(&self) -> &[u8] {
        match self.address.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_address(&mut self) {
        self.address = ::std::option::Option::None;
    }

    pub fn has_address(&self) -> bool {
        self.address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.address = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.address.is_none() {
            self.address = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.address.as_mut().unwrap()
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::vec::Vec<u8> {
        self.address.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 bandwidth = 15;

    pub fn bandwidth(&self) -> u32 {
        self.bandwidth.unwrap_or(0)
    }

    pub fn clear_bandwidth(&mut self) {
        self.bandwidth = ::std::option::Option::None;
    }

    pub fn has_bandwidth(&self) -> bool {
        self.bandwidth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bandwidth(&mut self, v: u32) {
        self.bandwidth = ::std::option::Option::Some(v);
    }

    // optional uint32 onlinesecs = 16;

    pub fn onlinesecs(&self) -> u32 {
        self.onlinesecs.unwrap_or(0)
    }

    pub fn clear_onlinesecs(&mut self) {
        self.onlinesecs = ::std::option::Option::None;
    }

    pub fn has_onlinesecs(&self) -> bool {
        self.onlinesecs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_onlinesecs(&mut self, v: u32) {
        self.onlinesecs = ::std::option::Option::Some(v);
    }

    // optional uint32 idlesecs = 17;

    pub fn idlesecs(&self) -> u32 {
        self.idlesecs.unwrap_or(0)
    }

    pub fn clear_idlesecs(&mut self) {
        self.idlesecs = ::std::option::Option::None;
    }

    pub fn has_idlesecs(&self) -> bool {
        self.idlesecs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_idlesecs(&mut self, v: u32) {
        self.idlesecs = ::std::option::Option::Some(v);
    }

    // optional bool strong_certificate = 18;

    pub fn strong_certificate(&self) -> bool {
        self.strong_certificate.unwrap_or(false)
    }

    pub fn clear_strong_certificate(&mut self) {
        self.strong_certificate = ::std::option::Option::None;
    }

    pub fn has_strong_certificate(&self) -> bool {
        self.strong_certificate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_strong_certificate(&mut self, v: bool) {
        self.strong_certificate = ::std::option::Option::Some(v);
    }

    // optional bool opus = 19;

    pub fn opus(&self) -> bool {
        self.opus.unwrap_or(false)
    }

    pub fn clear_opus(&mut self) {
        self.opus = ::std::option::Option::None;
    }

    pub fn has_opus(&self) -> bool {
        self.opus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_opus(&mut self, v: bool) {
        self.opus = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(19);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "session",
            |m: &UserStats| { &m.session },
            |m: &mut UserStats| { &mut m.session },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stats_only",
            |m: &UserStats| { &m.stats_only },
            |m: &mut UserStats| { &mut m.stats_only },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "certificates",
            |m: &UserStats| { &m.certificates },
            |m: &mut UserStats| { &mut m.certificates },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, user_stats::Stats>(
            "from_client",
            |m: &UserStats| { &m.from_client },
            |m: &mut UserStats| { &mut m.from_client },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, user_stats::Stats>(
            "from_server",
            |m: &UserStats| { &m.from_server },
            |m: &mut UserStats| { &mut m.from_server },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "udp_packets",
            |m: &UserStats| { &m.udp_packets },
            |m: &mut UserStats| { &mut m.udp_packets },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tcp_packets",
            |m: &UserStats| { &m.tcp_packets },
            |m: &mut UserStats| { &mut m.tcp_packets },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "udp_ping_avg",
            |m: &UserStats| { &m.udp_ping_avg },
            |m: &mut UserStats| { &mut m.udp_ping_avg },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "udp_ping_var",
            |m: &UserStats| { &m.udp_ping_var },
            |m: &mut UserStats| { &mut m.udp_ping_var },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tcp_ping_avg",
            |m: &UserStats| { &m.tcp_ping_avg },
            |m: &mut UserStats| { &mut m.tcp_ping_avg },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tcp_ping_var",
            |m: &UserStats| { &m.tcp_ping_var },
            |m: &mut UserStats| { &mut m.tcp_ping_var },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Version>(
            "version",
            |m: &UserStats| { &m.version },
            |m: &mut UserStats| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "celt_versions",
            |m: &UserStats| { &m.celt_versions },
            |m: &mut UserStats| { &mut m.celt_versions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "address",
            |m: &UserStats| { &m.address },
            |m: &mut UserStats| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bandwidth",
            |m: &UserStats| { &m.bandwidth },
            |m: &mut UserStats| { &mut m.bandwidth },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "onlinesecs",
            |m: &UserStats| { &m.onlinesecs },
            |m: &mut UserStats| { &mut m.onlinesecs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "idlesecs",
            |m: &UserStats| { &m.idlesecs },
            |m: &mut UserStats| { &mut m.idlesecs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "strong_certificate",
            |m: &UserStats| { &m.strong_certificate },
            |m: &mut UserStats| { &mut m.strong_certificate },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "opus",
            |m: &UserStats| { &m.opus },
            |m: &mut UserStats| { &mut m.opus },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserStats>(
            "UserStats",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UserStats {
    const NAME: &'static str = "UserStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.session = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.stats_only = ::std::option::Option::Some(is.read_bool()?);
                },
                26 => {
                    self.certificates.push(is.read_bytes()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.from_client)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.from_server)?;
                },
                48 => {
                    self.udp_packets = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.tcp_packets = ::std::option::Option::Some(is.read_uint32()?);
                },
                69 => {
                    self.udp_ping_avg = ::std::option::Option::Some(is.read_float()?);
                },
                77 => {
                    self.udp_ping_var = ::std::option::Option::Some(is.read_float()?);
                },
                85 => {
                    self.tcp_ping_avg = ::std::option::Option::Some(is.read_float()?);
                },
                93 => {
                    self.tcp_ping_var = ::std::option::Option::Some(is.read_float()?);
                },
                98 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.version)?;
                },
                106 => {
                    is.read_repeated_packed_int32_into(&mut self.celt_versions)?;
                },
                104 => {
                    self.celt_versions.push(is.read_int32()?);
                },
                114 => {
                    self.address = ::std::option::Option::Some(is.read_bytes()?);
                },
                120 => {
                    self.bandwidth = ::std::option::Option::Some(is.read_uint32()?);
                },
                128 => {
                    self.onlinesecs = ::std::option::Option::Some(is.read_uint32()?);
                },
                136 => {
                    self.idlesecs = ::std::option::Option::Some(is.read_uint32()?);
                },
                144 => {
                    self.strong_certificate = ::std::option::Option::Some(is.read_bool()?);
                },
                152 => {
                    self.opus = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.session {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.stats_only {
            my_size += 1 + 1;
        }
        for value in &self.certificates {
            my_size += ::protobuf::rt::bytes_size(3, &value);
        };
        if let Some(v) = self.from_client.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.from_server.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.udp_packets {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.tcp_packets {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.udp_ping_avg {
            my_size += 1 + 4;
        }
        if let Some(v) = self.udp_ping_var {
            my_size += 1 + 4;
        }
        if let Some(v) = self.tcp_ping_avg {
            my_size += 1 + 4;
        }
        if let Some(v) = self.tcp_ping_var {
            my_size += 1 + 4;
        }
        if let Some(v) = self.version.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.celt_versions {
            my_size += ::protobuf::rt::int32_size(13, *value);
        };
        if let Some(v) = self.address.as_ref() {
            my_size += ::protobuf::rt::bytes_size(14, &v);
        }
        if let Some(v) = self.bandwidth {
            my_size += ::protobuf::rt::uint32_size(15, v);
        }
        if let Some(v) = self.onlinesecs {
            my_size += ::protobuf::rt::uint32_size(16, v);
        }
        if let Some(v) = self.idlesecs {
            my_size += ::protobuf::rt::uint32_size(17, v);
        }
        if let Some(v) = self.strong_certificate {
            my_size += 2 + 1;
        }
        if let Some(v) = self.opus {
            my_size += 2 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.session {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.stats_only {
            os.write_bool(2, v)?;
        }
        for v in &self.certificates {
            os.write_bytes(3, &v)?;
        };
        if let Some(v) = self.from_client.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.from_server.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.udp_packets {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.tcp_packets {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.udp_ping_avg {
            os.write_float(8, v)?;
        }
        if let Some(v) = self.udp_ping_var {
            os.write_float(9, v)?;
        }
        if let Some(v) = self.tcp_ping_avg {
            os.write_float(10, v)?;
        }
        if let Some(v) = self.tcp_ping_var {
            os.write_float(11, v)?;
        }
        if let Some(v) = self.version.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        for v in &self.celt_versions {
            os.write_int32(13, *v)?;
        };
        if let Some(v) = self.address.as_ref() {
            os.write_bytes(14, v)?;
        }
        if let Some(v) = self.bandwidth {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.onlinesecs {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.idlesecs {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.strong_certificate {
            os.write_bool(18, v)?;
        }
        if let Some(v) = self.opus {
            os.write_bool(19, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UserStats {
        UserStats::new()
    }

    fn clear(&mut self) {
        self.session = ::std::option::Option::None;
        self.stats_only = ::std::option::Option::None;
        self.certificates.clear();
        self.from_client.clear();
        self.from_server.clear();
        self.udp_packets = ::std::option::Option::None;
        self.tcp_packets = ::std::option::Option::None;
        self.udp_ping_avg = ::std::option::Option::None;
        self.udp_ping_var = ::std::option::Option::None;
        self.tcp_ping_avg = ::std::option::Option::None;
        self.tcp_ping_var = ::std::option::Option::None;
        self.version.clear();
        self.celt_versions.clear();
        self.address = ::std::option::Option::None;
        self.bandwidth = ::std::option::Option::None;
        self.onlinesecs = ::std::option::Option::None;
        self.idlesecs = ::std::option::Option::None;
        self.strong_certificate = ::std::option::Option::None;
        self.opus = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UserStats {
        static instance: UserStats = UserStats {
            session: ::std::option::Option::None,
            stats_only: ::std::option::Option::None,
            certificates: ::std::vec::Vec::new(),
            from_client: ::protobuf::MessageField::none(),
            from_server: ::protobuf::MessageField::none(),
            udp_packets: ::std::option::Option::None,
            tcp_packets: ::std::option::Option::None,
            udp_ping_avg: ::std::option::Option::None,
            udp_ping_var: ::std::option::Option::None,
            tcp_ping_avg: ::std::option::Option::None,
            tcp_ping_var: ::std::option::Option::None,
            version: ::protobuf::MessageField::none(),
            celt_versions: ::std::vec::Vec::new(),
            address: ::std::option::Option::None,
            bandwidth: ::std::option::Option::None,
            onlinesecs: ::std::option::Option::None,
            idlesecs: ::std::option::Option::None,
            strong_certificate: ::std::option::Option::None,
            opus: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UserStats {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UserStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UserStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserStats {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `UserStats`
pub mod user_stats {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:MumbleProto.UserStats.Stats)
    pub struct Stats {
        // message fields
        // @@protoc_insertion_point(field:MumbleProto.UserStats.Stats.good)
        pub good: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:MumbleProto.UserStats.Stats.late)
        pub late: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:MumbleProto.UserStats.Stats.lost)
        pub lost: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:MumbleProto.UserStats.Stats.resync)
        pub resync: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:MumbleProto.UserStats.Stats.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Stats {
        fn default() -> &'a Stats {
            <Stats as ::protobuf::Message>::default_instance()
        }
    }

    impl Stats {
        pub fn new() -> Stats {
            ::std::default::Default::default()
        }

        // optional uint32 good = 1;

        pub fn good(&self) -> u32 {
            self.good.unwrap_or(0)
        }

        pub fn clear_good(&mut self) {
            self.good = ::std::option::Option::None;
        }

        pub fn has_good(&self) -> bool {
            self.good.is_some()
        }

        // Param is passed by value, moved
        pub fn set_good(&mut self, v: u32) {
            self.good = ::std::option::Option::Some(v);
        }

        // optional uint32 late = 2;

        pub fn late(&self) -> u32 {
            self.late.unwrap_or(0)
        }

        pub fn clear_late(&mut self) {
            self.late = ::std::option::Option::None;
        }

        pub fn has_late(&self) -> bool {
            self.late.is_some()
        }

        // Param is passed by value, moved
        pub fn set_late(&mut self, v: u32) {
            self.late = ::std::option::Option::Some(v);
        }

        // optional uint32 lost = 3;

        pub fn lost(&self) -> u32 {
            self.lost.unwrap_or(0)
        }

        pub fn clear_lost(&mut self) {
            self.lost = ::std::option::Option::None;
        }

        pub fn has_lost(&self) -> bool {
            self.lost.is_some()
        }

        // Param is passed by value, moved
        pub fn set_lost(&mut self, v: u32) {
            self.lost = ::std::option::Option::Some(v);
        }

        // optional uint32 resync = 4;

        pub fn resync(&self) -> u32 {
            self.resync.unwrap_or(0)
        }

        pub fn clear_resync(&mut self) {
            self.resync = ::std::option::Option::None;
        }

        pub fn has_resync(&self) -> bool {
            self.resync.is_some()
        }

        // Param is passed by value, moved
        pub fn set_resync(&mut self, v: u32) {
            self.resync = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "good",
                |m: &Stats| { &m.good },
                |m: &mut Stats| { &mut m.good },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "late",
                |m: &Stats| { &m.late },
                |m: &mut Stats| { &mut m.late },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "lost",
                |m: &Stats| { &m.lost },
                |m: &mut Stats| { &mut m.lost },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "resync",
                |m: &Stats| { &m.resync },
                |m: &mut Stats| { &mut m.resync },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Stats>(
                "UserStats.Stats",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Stats {
        const NAME: &'static str = "Stats";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.good = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.late = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.lost = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.resync = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.good {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.late {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.lost {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.resync {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.good {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.late {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.lost {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.resync {
                os.write_uint32(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Stats {
            Stats::new()
        }

        fn clear(&mut self) {
            self.good = ::std::option::Option::None;
            self.late = ::std::option::Option::None;
            self.lost = ::std::option::Option::None;
            self.resync = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Stats {
            static instance: Stats = Stats {
                good: ::std::option::Option::None,
                late: ::std::option::Option::None,
                lost: ::std::option::Option::None,
                resync: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Stats {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("UserStats.Stats").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Stats {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Stats {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:MumbleProto.RequestBlob)
pub struct RequestBlob {
    // message fields
    // @@protoc_insertion_point(field:MumbleProto.RequestBlob.session_texture)
    pub session_texture: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:MumbleProto.RequestBlob.session_comment)
    pub session_comment: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:MumbleProto.RequestBlob.channel_description)
    pub channel_description: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:MumbleProto.RequestBlob.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RequestBlob {
    fn default() -> &'a RequestBlob {
        <RequestBlob as ::protobuf::Message>::default_instance()
    }
}

impl RequestBlob {
    pub fn new() -> RequestBlob {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "session_texture",
            |m: &RequestBlob| { &m.session_texture },
            |m: &mut RequestBlob| { &mut m.session_texture },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "session_comment",
            |m: &RequestBlob| { &m.session_comment },
            |m: &mut RequestBlob| { &mut m.session_comment },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "channel_description",
            |m: &RequestBlob| { &m.channel_description },
            |m: &mut RequestBlob| { &mut m.channel_description },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RequestBlob>(
            "RequestBlob",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RequestBlob {
    const NAME: &'static str = "RequestBlob";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.session_texture)?;
                },
                8 => {
                    self.session_texture.push(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.session_comment)?;
                },
                16 => {
                    self.session_comment.push(is.read_uint32()?);
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.channel_description)?;
                },
                24 => {
                    self.channel_description.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.session_texture {
            my_size += ::protobuf::rt::uint32_size(1, *value);
        };
        for value in &self.session_comment {
            my_size += ::protobuf::rt::uint32_size(2, *value);
        };
        for value in &self.channel_description {
            my_size += ::protobuf::rt::uint32_size(3, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.session_texture {
            os.write_uint32(1, *v)?;
        };
        for v in &self.session_comment {
            os.write_uint32(2, *v)?;
        };
        for v in &self.channel_description {
            os.write_uint32(3, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RequestBlob {
        RequestBlob::new()
    }

    fn clear(&mut self) {
        self.session_texture.clear();
        self.session_comment.clear();
        self.channel_description.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RequestBlob {
        static instance: RequestBlob = RequestBlob {
            session_texture: ::std::vec::Vec::new(),
            session_comment: ::std::vec::Vec::new(),
            channel_description: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RequestBlob {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RequestBlob").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RequestBlob {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestBlob {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:MumbleProto.ServerConfig)
pub struct ServerConfig {
    // message fields
    // @@protoc_insertion_point(field:MumbleProto.ServerConfig.max_bandwidth)
    pub max_bandwidth: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:MumbleProto.ServerConfig.welcome_text)
    pub welcome_text: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:MumbleProto.ServerConfig.allow_html)
    pub allow_html: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:MumbleProto.ServerConfig.message_length)
    pub message_length: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:MumbleProto.ServerConfig.image_message_length)
    pub image_message_length: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:MumbleProto.ServerConfig.max_users)
    pub max_users: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:MumbleProto.ServerConfig.recording_allowed)
    pub recording_allowed: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:MumbleProto.ServerConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ServerConfig {
    fn default() -> &'a ServerConfig {
        <ServerConfig as ::protobuf::Message>::default_instance()
    }
}

impl ServerConfig {
    pub fn new() -> ServerConfig {
        ::std::default::Default::default()
    }

    // optional uint32 max_bandwidth = 1;

    pub fn max_bandwidth(&self) -> u32 {
        self.max_bandwidth.unwrap_or(0)
    }

    pub fn clear_max_bandwidth(&mut self) {
        self.max_bandwidth = ::std::option::Option::None;
    }

    pub fn has_max_bandwidth(&self) -> bool {
        self.max_bandwidth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_bandwidth(&mut self, v: u32) {
        self.max_bandwidth = ::std::option::Option::Some(v);
    }

    // optional string welcome_text = 2;

    pub fn welcome_text(&self) -> &str {
        match self.welcome_text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_welcome_text(&mut self) {
        self.welcome_text = ::std::option::Option::None;
    }

    pub fn has_welcome_text(&self) -> bool {
        self.welcome_text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_welcome_text(&mut self, v: ::std::string::String) {
        self.welcome_text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_welcome_text(&mut self) -> &mut ::std::string::String {
        if self.welcome_text.is_none() {
            self.welcome_text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.welcome_text.as_mut().unwrap()
    }

    // Take field
    pub fn take_welcome_text(&mut self) -> ::std::string::String {
        self.welcome_text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool allow_html = 3;

    pub fn allow_html(&self) -> bool {
        self.allow_html.unwrap_or(false)
    }

    pub fn clear_allow_html(&mut self) {
        self.allow_html = ::std::option::Option::None;
    }

    pub fn has_allow_html(&self) -> bool {
        self.allow_html.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allow_html(&mut self, v: bool) {
        self.allow_html = ::std::option::Option::Some(v);
    }

    // optional uint32 message_length = 4;

    pub fn message_length(&self) -> u32 {
        self.message_length.unwrap_or(0)
    }

    pub fn clear_message_length(&mut self) {
        self.message_length = ::std::option::Option::None;
    }

    pub fn has_message_length(&self) -> bool {
        self.message_length.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_length(&mut self, v: u32) {
        self.message_length = ::std::option::Option::Some(v);
    }

    // optional uint32 image_message_length = 5;

    pub fn image_message_length(&self) -> u32 {
        self.image_message_length.unwrap_or(0)
    }

    pub fn clear_image_message_length(&mut self) {
        self.image_message_length = ::std::option::Option::None;
    }

    pub fn has_image_message_length(&self) -> bool {
        self.image_message_length.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image_message_length(&mut self, v: u32) {
        self.image_message_length = ::std::option::Option::Some(v);
    }

    // optional uint32 max_users = 6;

    pub fn max_users(&self) -> u32 {
        self.max_users.unwrap_or(0)
    }

    pub fn clear_max_users(&mut self) {
        self.max_users = ::std::option::Option::None;
    }

    pub fn has_max_users(&self) -> bool {
        self.max_users.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_users(&mut self, v: u32) {
        self.max_users = ::std::option::Option::Some(v);
    }

    // optional bool recording_allowed = 7;

    pub fn recording_allowed(&self) -> bool {
        self.recording_allowed.unwrap_or(false)
    }

    pub fn clear_recording_allowed(&mut self) {
        self.recording_allowed = ::std::option::Option::None;
    }

    pub fn has_recording_allowed(&self) -> bool {
        self.recording_allowed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recording_allowed(&mut self, v: bool) {
        self.recording_allowed = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_bandwidth",
            |m: &ServerConfig| { &m.max_bandwidth },
            |m: &mut ServerConfig| { &mut m.max_bandwidth },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "welcome_text",
            |m: &ServerConfig| { &m.welcome_text },
            |m: &mut ServerConfig| { &mut m.welcome_text },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "allow_html",
            |m: &ServerConfig| { &m.allow_html },
            |m: &mut ServerConfig| { &mut m.allow_html },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message_length",
            |m: &ServerConfig| { &m.message_length },
            |m: &mut ServerConfig| { &mut m.message_length },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "image_message_length",
            |m: &ServerConfig| { &m.image_message_length },
            |m: &mut ServerConfig| { &mut m.image_message_length },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_users",
            |m: &ServerConfig| { &m.max_users },
            |m: &mut ServerConfig| { &mut m.max_users },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "recording_allowed",
            |m: &ServerConfig| { &m.recording_allowed },
            |m: &mut ServerConfig| { &mut m.recording_allowed },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ServerConfig>(
            "ServerConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ServerConfig {
    const NAME: &'static str = "ServerConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.max_bandwidth = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.welcome_text = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.allow_html = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.message_length = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.image_message_length = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.max_users = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.recording_allowed = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.max_bandwidth {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.welcome_text.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.allow_html {
            my_size += 1 + 1;
        }
        if let Some(v) = self.message_length {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.image_message_length {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.max_users {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.recording_allowed {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.max_bandwidth {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.welcome_text.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.allow_html {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.message_length {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.image_message_length {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.max_users {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.recording_allowed {
            os.write_bool(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ServerConfig {
        ServerConfig::new()
    }

    fn clear(&mut self) {
        self.max_bandwidth = ::std::option::Option::None;
        self.welcome_text = ::std::option::Option::None;
        self.allow_html = ::std::option::Option::None;
        self.message_length = ::std::option::Option::None;
        self.image_message_length = ::std::option::Option::None;
        self.max_users = ::std::option::Option::None;
        self.recording_allowed = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ServerConfig {
        static instance: ServerConfig = ServerConfig {
            max_bandwidth: ::std::option::Option::None,
            welcome_text: ::std::option::Option::None,
            allow_html: ::std::option::Option::None,
            message_length: ::std::option::Option::None,
            image_message_length: ::std::option::Option::None,
            max_users: ::std::option::Option::None,
            recording_allowed: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ServerConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ServerConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ServerConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServerConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:MumbleProto.SuggestConfig)
pub struct SuggestConfig {
    // message fields
    // @@protoc_insertion_point(field:MumbleProto.SuggestConfig.version)
    pub version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:MumbleProto.SuggestConfig.positional)
    pub positional: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:MumbleProto.SuggestConfig.push_to_talk)
    pub push_to_talk: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:MumbleProto.SuggestConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SuggestConfig {
    fn default() -> &'a SuggestConfig {
        <SuggestConfig as ::protobuf::Message>::default_instance()
    }
}

impl SuggestConfig {
    pub fn new() -> SuggestConfig {
        ::std::default::Default::default()
    }

    // optional uint32 version = 1;

    pub fn version(&self) -> u32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional bool positional = 2;

    pub fn positional(&self) -> bool {
        self.positional.unwrap_or(false)
    }

    pub fn clear_positional(&mut self) {
        self.positional = ::std::option::Option::None;
    }

    pub fn has_positional(&self) -> bool {
        self.positional.is_some()
    }

    // Param is passed by value, moved
    pub fn set_positional(&mut self, v: bool) {
        self.positional = ::std::option::Option::Some(v);
    }

    // optional bool push_to_talk = 3;

    pub fn push_to_talk(&self) -> bool {
        self.push_to_talk.unwrap_or(false)
    }

    pub fn clear_push_to_talk(&mut self) {
        self.push_to_talk = ::std::option::Option::None;
    }

    pub fn has_push_to_talk(&self) -> bool {
        self.push_to_talk.is_some()
    }

    // Param is passed by value, moved
    pub fn set_push_to_talk(&mut self, v: bool) {
        self.push_to_talk = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &SuggestConfig| { &m.version },
            |m: &mut SuggestConfig| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "positional",
            |m: &SuggestConfig| { &m.positional },
            |m: &mut SuggestConfig| { &mut m.positional },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "push_to_talk",
            |m: &SuggestConfig| { &m.push_to_talk },
            |m: &mut SuggestConfig| { &mut m.push_to_talk },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SuggestConfig>(
            "SuggestConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SuggestConfig {
    const NAME: &'static str = "SuggestConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.version = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.positional = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.push_to_talk = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.positional {
            my_size += 1 + 1;
        }
        if let Some(v) = self.push_to_talk {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.positional {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.push_to_talk {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SuggestConfig {
        SuggestConfig::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.positional = ::std::option::Option::None;
        self.push_to_talk = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SuggestConfig {
        static instance: SuggestConfig = SuggestConfig {
            version: ::std::option::Option::None,
            positional: ::std::option::Option::None,
            push_to_talk: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SuggestConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SuggestConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SuggestConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SuggestConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:MumbleProto.PluginDataTransmission)
pub struct PluginDataTransmission {
    // message fields
    // @@protoc_insertion_point(field:MumbleProto.PluginDataTransmission.senderSession)
    pub senderSession: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:MumbleProto.PluginDataTransmission.receiverSessions)
    pub receiverSessions: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:MumbleProto.PluginDataTransmission.data)
    pub data: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:MumbleProto.PluginDataTransmission.dataID)
    pub dataID: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:MumbleProto.PluginDataTransmission.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PluginDataTransmission {
    fn default() -> &'a PluginDataTransmission {
        <PluginDataTransmission as ::protobuf::Message>::default_instance()
    }
}

impl PluginDataTransmission {
    pub fn new() -> PluginDataTransmission {
        ::std::default::Default::default()
    }

    // optional uint32 senderSession = 1;

    pub fn senderSession(&self) -> u32 {
        self.senderSession.unwrap_or(0)
    }

    pub fn clear_senderSession(&mut self) {
        self.senderSession = ::std::option::Option::None;
    }

    pub fn has_senderSession(&self) -> bool {
        self.senderSession.is_some()
    }

    // Param is passed by value, moved
    pub fn set_senderSession(&mut self, v: u32) {
        self.senderSession = ::std::option::Option::Some(v);
    }

    // optional bytes data = 3;

    pub fn data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string dataID = 4;

    pub fn dataID(&self) -> &str {
        match self.dataID.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_dataID(&mut self) {
        self.dataID = ::std::option::Option::None;
    }

    pub fn has_dataID(&self) -> bool {
        self.dataID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dataID(&mut self, v: ::std::string::String) {
        self.dataID = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dataID(&mut self) -> &mut ::std::string::String {
        if self.dataID.is_none() {
            self.dataID = ::std::option::Option::Some(::std::string::String::new());
        }
        self.dataID.as_mut().unwrap()
    }

    // Take field
    pub fn take_dataID(&mut self) -> ::std::string::String {
        self.dataID.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "senderSession",
            |m: &PluginDataTransmission| { &m.senderSession },
            |m: &mut PluginDataTransmission| { &mut m.senderSession },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "receiverSessions",
            |m: &PluginDataTransmission| { &m.receiverSessions },
            |m: &mut PluginDataTransmission| { &mut m.receiverSessions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data",
            |m: &PluginDataTransmission| { &m.data },
            |m: &mut PluginDataTransmission| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dataID",
            |m: &PluginDataTransmission| { &m.dataID },
            |m: &mut PluginDataTransmission| { &mut m.dataID },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PluginDataTransmission>(
            "PluginDataTransmission",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PluginDataTransmission {
    const NAME: &'static str = "PluginDataTransmission";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.senderSession = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.receiverSessions)?;
                },
                16 => {
                    self.receiverSessions.push(is.read_uint32()?);
                },
                26 => {
                    self.data = ::std::option::Option::Some(is.read_bytes()?);
                },
                34 => {
                    self.dataID = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.senderSession {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::vec_packed_uint32_size(2, &self.receiverSessions);
        if let Some(v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.dataID.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.senderSession {
            os.write_uint32(1, v)?;
        }
        os.write_repeated_packed_uint32(2, &self.receiverSessions)?;
        if let Some(v) = self.data.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.dataID.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PluginDataTransmission {
        PluginDataTransmission::new()
    }

    fn clear(&mut self) {
        self.senderSession = ::std::option::Option::None;
        self.receiverSessions.clear();
        self.data = ::std::option::Option::None;
        self.dataID = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PluginDataTransmission {
        static instance: PluginDataTransmission = PluginDataTransmission {
            senderSession: ::std::option::Option::None,
            receiverSessions: ::std::vec::Vec::new(),
            data: ::std::option::Option::None,
            dataID: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PluginDataTransmission {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PluginDataTransmission").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PluginDataTransmission {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PluginDataTransmission {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0cMumble.proto\x12\x0bMumbleProto\"l\n\x07Version\x12\x18\n\x07versi\
    on\x18\x01\x20\x01(\rR\x07version\x12\x18\n\x07release\x18\x02\x20\x01(\
    \tR\x07release\x12\x0e\n\x02os\x18\x03\x20\x01(\tR\x02os\x12\x1d\n\nos_v\
    ersion\x18\x04\x20\x01(\tR\tosVersion\"#\n\tUDPTunnel\x12\x16\n\x06packe\
    t\x18\x01\x20\x02(\x0cR\x06packet\"\x9e\x01\n\x0cAuthenticate\x12\x1a\n\
    \x08username\x18\x01\x20\x01(\tR\x08username\x12\x1a\n\x08password\x18\
    \x02\x20\x01(\tR\x08password\x12\x16\n\x06tokens\x18\x03\x20\x03(\tR\x06\
    tokens\x12#\n\rcelt_versions\x18\x04\x20\x03(\x05R\x0cceltVersions\x12\
    \x19\n\x04opus\x18\x05\x20\x01(\x08:\x05falseR\x04opus\"\xc2\x02\n\x04Pi\
    ng\x12\x1c\n\ttimestamp\x18\x01\x20\x01(\x04R\ttimestamp\x12\x12\n\x04go\
    od\x18\x02\x20\x01(\rR\x04good\x12\x12\n\x04late\x18\x03\x20\x01(\rR\x04\
    late\x12\x12\n\x04lost\x18\x04\x20\x01(\rR\x04lost\x12\x16\n\x06resync\
    \x18\x05\x20\x01(\rR\x06resync\x12\x1f\n\x0budp_packets\x18\x06\x20\x01(\
    \rR\nudpPackets\x12\x1f\n\x0btcp_packets\x18\x07\x20\x01(\rR\ntcpPackets\
    \x12\x20\n\x0cudp_ping_avg\x18\x08\x20\x01(\x02R\nudpPingAvg\x12\x20\n\
    \x0cudp_ping_var\x18\t\x20\x01(\x02R\nudpPingVar\x12\x20\n\x0ctcp_ping_a\
    vg\x18\n\x20\x01(\x02R\ntcpPingAvg\x12\x20\n\x0ctcp_ping_var\x18\x0b\x20\
    \x01(\x02R\ntcpPingVar\"\x85\x02\n\x06Reject\x122\n\x04type\x18\x01\x20\
    \x01(\x0e2\x1e.MumbleProto.Reject.RejectTypeR\x04type\x12\x16\n\x06reaso\
    n\x18\x02\x20\x01(\tR\x06reason\"\xae\x01\n\nRejectType\x12\x08\n\x04Non\
    e\x10\0\x12\x10\n\x0cWrongVersion\x10\x01\x12\x13\n\x0fInvalidUsername\
    \x10\x02\x12\x0f\n\x0bWrongUserPW\x10\x03\x12\x11\n\rWrongServerPW\x10\
    \x04\x12\x11\n\rUsernameInUse\x10\x05\x12\x0e\n\nServerFull\x10\x06\x12\
    \x11\n\rNoCertificate\x10\x07\x12\x15\n\x11AuthenticatorFail\x10\x08\"\
    \x90\x01\n\nServerSync\x12\x18\n\x07session\x18\x01\x20\x01(\rR\x07sessi\
    on\x12#\n\rmax_bandwidth\x18\x02\x20\x01(\rR\x0cmaxBandwidth\x12!\n\x0cw\
    elcome_text\x18\x03\x20\x01(\tR\x0bwelcomeText\x12\x20\n\x0bpermissions\
    \x18\x04\x20\x01(\x04R\x0bpermissions\".\n\rChannelRemove\x12\x1d\n\ncha\
    nnel_id\x18\x01\x20\x02(\rR\tchannelId\"\xaa\x03\n\x0cChannelState\x12\
    \x1d\n\nchannel_id\x18\x01\x20\x01(\rR\tchannelId\x12\x16\n\x06parent\
    \x18\x02\x20\x01(\rR\x06parent\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04\
    name\x12\x14\n\x05links\x18\x04\x20\x03(\rR\x05links\x12\x20\n\x0bdescri\
    ption\x18\x05\x20\x01(\tR\x0bdescription\x12\x1b\n\tlinks_add\x18\x06\
    \x20\x03(\rR\x08linksAdd\x12!\n\x0clinks_remove\x18\x07\x20\x03(\rR\x0bl\
    inksRemove\x12#\n\ttemporary\x18\x08\x20\x01(\x08:\x05falseR\ttemporary\
    \x12\x1d\n\x08position\x18\t\x20\x01(\x05:\x010R\x08position\x12)\n\x10d\
    escription_hash\x18\n\x20\x01(\x0cR\x0fdescriptionHash\x12\x1b\n\tmax_us\
    ers\x18\x0b\x20\x01(\rR\x08maxUsers\x12.\n\x13is_enter_restricted\x18\
    \x0c\x20\x01(\x08R\x11isEnterRestricted\x12\x1b\n\tcan_enter\x18\r\x20\
    \x01(\x08R\x08canEnter\"f\n\nUserRemove\x12\x18\n\x07session\x18\x01\x20\
    \x02(\rR\x07session\x12\x14\n\x05actor\x18\x02\x20\x01(\rR\x05actor\x12\
    \x16\n\x06reason\x18\x03\x20\x01(\tR\x06reason\x12\x10\n\x03ban\x18\x04\
    \x20\x01(\x08R\x03ban\"\xd2\x05\n\tUserState\x12\x18\n\x07session\x18\
    \x01\x20\x01(\rR\x07session\x12\x14\n\x05actor\x18\x02\x20\x01(\rR\x05ac\
    tor\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12\x17\n\x07user_id\
    \x18\x04\x20\x01(\rR\x06userId\x12\x1d\n\nchannel_id\x18\x05\x20\x01(\rR\
    \tchannelId\x12\x12\n\x04mute\x18\x06\x20\x01(\x08R\x04mute\x12\x12\n\
    \x04deaf\x18\x07\x20\x01(\x08R\x04deaf\x12\x1a\n\x08suppress\x18\x08\x20\
    \x01(\x08R\x08suppress\x12\x1b\n\tself_mute\x18\t\x20\x01(\x08R\x08selfM\
    ute\x12\x1b\n\tself_deaf\x18\n\x20\x01(\x08R\x08selfDeaf\x12\x18\n\x07te\
    xture\x18\x0b\x20\x01(\x0cR\x07texture\x12%\n\x0eplugin_context\x18\x0c\
    \x20\x01(\x0cR\rpluginContext\x12'\n\x0fplugin_identity\x18\r\x20\x01(\t\
    R\x0epluginIdentity\x12\x18\n\x07comment\x18\x0e\x20\x01(\tR\x07comment\
    \x12\x12\n\x04hash\x18\x0f\x20\x01(\tR\x04hash\x12!\n\x0ccomment_hash\
    \x18\x10\x20\x01(\x0cR\x0bcommentHash\x12!\n\x0ctexture_hash\x18\x11\x20\
    \x01(\x0cR\x0btextureHash\x12)\n\x10priority_speaker\x18\x12\x20\x01(\
    \x08R\x0fprioritySpeaker\x12\x1c\n\trecording\x18\x13\x20\x01(\x08R\trec\
    ording\x126\n\x17temporary_access_tokens\x18\x14\x20\x03(\tR\x15temporar\
    yAccessTokens\x122\n\x15listening_channel_add\x18\x15\x20\x03(\rR\x13lis\
    teningChannelAdd\x128\n\x18listening_channel_remove\x18\x16\x20\x03(\rR\
    \x16listeningChannelRemove\"\x86\x02\n\x07BanList\x121\n\x04bans\x18\x01\
    \x20\x03(\x0b2\x1d.MumbleProto.BanList.BanEntryR\x04bans\x12\x1b\n\x05qu\
    ery\x18\x02\x20\x01(\x08:\x05falseR\x05query\x1a\xaa\x01\n\x08BanEntry\
    \x12\x18\n\x07address\x18\x01\x20\x02(\x0cR\x07address\x12\x12\n\x04mask\
    \x18\x02\x20\x02(\rR\x04mask\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04na\
    me\x12\x12\n\x04hash\x18\x04\x20\x01(\tR\x04hash\x12\x16\n\x06reason\x18\
    \x05\x20\x01(\tR\x06reason\x12\x14\n\x05start\x18\x06\x20\x01(\tR\x05sta\
    rt\x12\x1a\n\x08duration\x18\x07\x20\x01(\rR\x08duration\"\x8f\x01\n\x0b\
    TextMessage\x12\x14\n\x05actor\x18\x01\x20\x01(\rR\x05actor\x12\x18\n\
    \x07session\x18\x02\x20\x03(\rR\x07session\x12\x1d\n\nchannel_id\x18\x03\
    \x20\x03(\rR\tchannelId\x12\x17\n\x07tree_id\x18\x04\x20\x03(\rR\x06tree\
    Id\x12\x18\n\x07message\x18\x05\x20\x02(\tR\x07message\"\xdb\x03\n\x10Pe\
    rmissionDenied\x12\x1e\n\npermission\x18\x01\x20\x01(\rR\npermission\x12\
    \x1d\n\nchannel_id\x18\x02\x20\x01(\rR\tchannelId\x12\x18\n\x07session\
    \x18\x03\x20\x01(\rR\x07session\x12\x16\n\x06reason\x18\x04\x20\x01(\tR\
    \x06reason\x12:\n\x04type\x18\x05\x20\x01(\x0e2&.MumbleProto.PermissionD\
    enied.DenyTypeR\x04type\x12\x12\n\x04name\x18\x06\x20\x01(\tR\x04name\"\
    \x85\x02\n\x08DenyType\x12\x08\n\x04Text\x10\0\x12\x0e\n\nPermission\x10\
    \x01\x12\r\n\tSuperUser\x10\x02\x12\x0f\n\x0bChannelName\x10\x03\x12\x0f\
    \n\x0bTextTooLong\x10\x04\x12\x07\n\x03H9K\x10\x05\x12\x14\n\x10Temporar\
    yChannel\x10\x06\x12\x16\n\x12MissingCertificate\x10\x07\x12\x0c\n\x08Us\
    erName\x10\x08\x12\x0f\n\x0bChannelFull\x10\t\x12\x10\n\x0cNestingLimit\
    \x10\n\x12\x15\n\x11ChannelCountLimit\x10\x0b\x12\x18\n\x14ChannelListen\
    erLimit\x10\x0c\x12\x15\n\x11UserListenerLimit\x10\r\"\x84\x05\n\x03ACL\
    \x12\x1d\n\nchannel_id\x18\x01\x20\x02(\rR\tchannelId\x12'\n\x0cinherit_\
    acls\x18\x02\x20\x01(\x08:\x04trueR\x0binheritAcls\x122\n\x06groups\x18\
    \x03\x20\x03(\x0b2\x1a.MumbleProto.ACL.ChanGroupR\x06groups\x12,\n\x04ac\
    ls\x18\x04\x20\x03(\x0b2\x18.MumbleProto.ACL.ChanACLR\x04acls\x12\x1b\n\
    \x05query\x18\x05\x20\x01(\x08:\x05falseR\x05query\x1a\xe2\x01\n\tChanGr\
    oup\x12\x12\n\x04name\x18\x01\x20\x02(\tR\x04name\x12\"\n\tinherited\x18\
    \x02\x20\x01(\x08:\x04trueR\tinherited\x12\x1e\n\x07inherit\x18\x03\x20\
    \x01(\x08:\x04trueR\x07inherit\x12&\n\x0binheritable\x18\x04\x20\x01(\
    \x08:\x04trueR\x0binheritable\x12\x10\n\x03add\x18\x05\x20\x03(\rR\x03ad\
    d\x12\x16\n\x06remove\x18\x06\x20\x03(\rR\x06remove\x12+\n\x11inherited_\
    members\x18\x07\x20\x03(\rR\x10inheritedMembers\x1a\xd0\x01\n\x07ChanACL\
    \x12#\n\napply_here\x18\x01\x20\x01(\x08:\x04trueR\tapplyHere\x12#\n\nap\
    ply_subs\x18\x02\x20\x01(\x08:\x04trueR\tapplySubs\x12\"\n\tinherited\
    \x18\x03\x20\x01(\x08:\x04trueR\tinherited\x12\x17\n\x07user_id\x18\x04\
    \x20\x01(\rR\x06userId\x12\x14\n\x05group\x18\x05\x20\x01(\tR\x05group\
    \x12\x14\n\x05grant\x18\x06\x20\x01(\rR\x05grant\x12\x12\n\x04deny\x18\
    \x07\x20\x01(\rR\x04deny\"4\n\nQueryUsers\x12\x10\n\x03ids\x18\x01\x20\
    \x03(\rR\x03ids\x12\x14\n\x05names\x18\x02\x20\x03(\tR\x05names\"d\n\nCr\
    yptSetup\x12\x10\n\x03key\x18\x01\x20\x01(\x0cR\x03key\x12!\n\x0cclient_\
    nonce\x18\x02\x20\x01(\x0cR\x0bclientNonce\x12!\n\x0cserver_nonce\x18\
    \x03\x20\x01(\x0cR\x0bserverNonce\"\xf5\x01\n\x13ContextActionModify\x12\
    \x16\n\x06action\x18\x01\x20\x02(\tR\x06action\x12\x12\n\x04text\x18\x02\
    \x20\x01(\tR\x04text\x12\x18\n\x07context\x18\x03\x20\x01(\rR\x07context\
    \x12H\n\toperation\x18\x04\x20\x01(\x0e2*.MumbleProto.ContextActionModif\
    y.OperationR\toperation\",\n\x07Context\x12\n\n\x06Server\x10\x01\x12\
    \x0b\n\x07Channel\x10\x02\x12\x08\n\x04User\x10\x04\"\x20\n\tOperation\
    \x12\x07\n\x03Add\x10\0\x12\n\n\x06Remove\x10\x01\"`\n\rContextAction\
    \x12\x18\n\x07session\x18\x01\x20\x01(\rR\x07session\x12\x1d\n\nchannel_\
    id\x18\x02\x20\x01(\rR\tchannelId\x12\x16\n\x06action\x18\x03\x20\x02(\t\
    R\x06action\"\xb1\x01\n\x08UserList\x120\n\x05users\x18\x01\x20\x03(\x0b\
    2\x1a.MumbleProto.UserList.UserR\x05users\x1as\n\x04User\x12\x17\n\x07us\
    er_id\x18\x01\x20\x02(\rR\x06userId\x12\x12\n\x04name\x18\x02\x20\x01(\t\
    R\x04name\x12\x1b\n\tlast_seen\x18\x03\x20\x01(\tR\x08lastSeen\x12!\n\
    \x0clast_channel\x18\x04\x20\x01(\rR\x0blastChannel\"\xf2\x01\n\x0bVoice\
    Target\x12\x0e\n\x02id\x18\x01\x20\x01(\rR\x02id\x129\n\x07targets\x18\
    \x02\x20\x03(\x0b2\x1f.MumbleProto.VoiceTarget.TargetR\x07targets\x1a\
    \x97\x01\n\x06Target\x12\x18\n\x07session\x18\x01\x20\x03(\rR\x07session\
    \x12\x1d\n\nchannel_id\x18\x02\x20\x01(\rR\tchannelId\x12\x14\n\x05group\
    \x18\x03\x20\x01(\tR\x05group\x12\x1b\n\x05links\x18\x04\x20\x01(\x08:\
    \x05falseR\x05links\x12!\n\x08children\x18\x05\x20\x01(\x08:\x05falseR\
    \x08children\"o\n\x0fPermissionQuery\x12\x1d\n\nchannel_id\x18\x01\x20\
    \x01(\rR\tchannelId\x12\x20\n\x0bpermissions\x18\x02\x20\x01(\rR\x0bperm\
    issions\x12\x1b\n\x05flush\x18\x03\x20\x01(\x08:\x05falseR\x05flush\"|\n\
    \x0cCodecVersion\x12\x14\n\x05alpha\x18\x01\x20\x02(\x05R\x05alpha\x12\
    \x12\n\x04beta\x18\x02\x20\x02(\x05R\x04beta\x12'\n\x0cprefer_alpha\x18\
    \x03\x20\x02(\x08:\x04trueR\x0bpreferAlpha\x12\x19\n\x04opus\x18\x04\x20\
    \x01(\x08:\x05falseR\x04opus\"\xae\x06\n\tUserStats\x12\x18\n\x07session\
    \x18\x01\x20\x01(\rR\x07session\x12$\n\nstats_only\x18\x02\x20\x01(\x08:\
    \x05falseR\tstatsOnly\x12\"\n\x0ccertificates\x18\x03\x20\x03(\x0cR\x0cc\
    ertificates\x12=\n\x0bfrom_client\x18\x04\x20\x01(\x0b2\x1c.MumbleProto.\
    UserStats.StatsR\nfromClient\x12=\n\x0bfrom_server\x18\x05\x20\x01(\x0b2\
    \x1c.MumbleProto.UserStats.StatsR\nfromServer\x12\x1f\n\x0budp_packets\
    \x18\x06\x20\x01(\rR\nudpPackets\x12\x1f\n\x0btcp_packets\x18\x07\x20\
    \x01(\rR\ntcpPackets\x12\x20\n\x0cudp_ping_avg\x18\x08\x20\x01(\x02R\nud\
    pPingAvg\x12\x20\n\x0cudp_ping_var\x18\t\x20\x01(\x02R\nudpPingVar\x12\
    \x20\n\x0ctcp_ping_avg\x18\n\x20\x01(\x02R\ntcpPingAvg\x12\x20\n\x0ctcp_\
    ping_var\x18\x0b\x20\x01(\x02R\ntcpPingVar\x12.\n\x07version\x18\x0c\x20\
    \x01(\x0b2\x14.MumbleProto.VersionR\x07version\x12#\n\rcelt_versions\x18\
    \r\x20\x03(\x05R\x0cceltVersions\x12\x18\n\x07address\x18\x0e\x20\x01(\
    \x0cR\x07address\x12\x1c\n\tbandwidth\x18\x0f\x20\x01(\rR\tbandwidth\x12\
    \x1e\n\nonlinesecs\x18\x10\x20\x01(\rR\nonlinesecs\x12\x1a\n\x08idlesecs\
    \x18\x11\x20\x01(\rR\x08idlesecs\x124\n\x12strong_certificate\x18\x12\
    \x20\x01(\x08:\x05falseR\x11strongCertificate\x12\x19\n\x04opus\x18\x13\
    \x20\x01(\x08:\x05falseR\x04opus\x1a[\n\x05Stats\x12\x12\n\x04good\x18\
    \x01\x20\x01(\rR\x04good\x12\x12\n\x04late\x18\x02\x20\x01(\rR\x04late\
    \x12\x12\n\x04lost\x18\x03\x20\x01(\rR\x04lost\x12\x16\n\x06resync\x18\
    \x04\x20\x01(\rR\x06resync\"\x90\x01\n\x0bRequestBlob\x12'\n\x0fsession_\
    texture\x18\x01\x20\x03(\rR\x0esessionTexture\x12'\n\x0fsession_comment\
    \x18\x02\x20\x03(\rR\x0esessionComment\x12/\n\x13channel_description\x18\
    \x03\x20\x03(\rR\x12channelDescription\"\x98\x02\n\x0cServerConfig\x12#\
    \n\rmax_bandwidth\x18\x01\x20\x01(\rR\x0cmaxBandwidth\x12!\n\x0cwelcome_\
    text\x18\x02\x20\x01(\tR\x0bwelcomeText\x12\x1d\n\nallow_html\x18\x03\
    \x20\x01(\x08R\tallowHtml\x12%\n\x0emessage_length\x18\x04\x20\x01(\rR\r\
    messageLength\x120\n\x14image_message_length\x18\x05\x20\x01(\rR\x12imag\
    eMessageLength\x12\x1b\n\tmax_users\x18\x06\x20\x01(\rR\x08maxUsers\x12+\
    \n\x11recording_allowed\x18\x07\x20\x01(\x08R\x10recordingAllowed\"k\n\r\
    SuggestConfig\x12\x18\n\x07version\x18\x01\x20\x01(\rR\x07version\x12\
    \x1e\n\npositional\x18\x02\x20\x01(\x08R\npositional\x12\x20\n\x0cpush_t\
    o_talk\x18\x03\x20\x01(\x08R\npushToTalk\"\x9a\x01\n\x16PluginDataTransm\
    ission\x12$\n\rsenderSession\x18\x01\x20\x01(\rR\rsenderSession\x12.\n\
    \x10receiverSessions\x18\x02\x20\x03(\rR\x10receiverSessionsB\x02\x10\
    \x01\x12\x12\n\x04data\x18\x03\x20\x01(\x0cR\x04data\x12\x16\n\x06dataID\
    \x18\x04\x20\x01(\tR\x06dataIDB\x02H\x01\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(33);
            messages.push(Version::generated_message_descriptor_data());
            messages.push(UDPTunnel::generated_message_descriptor_data());
            messages.push(Authenticate::generated_message_descriptor_data());
            messages.push(Ping::generated_message_descriptor_data());
            messages.push(Reject::generated_message_descriptor_data());
            messages.push(ServerSync::generated_message_descriptor_data());
            messages.push(ChannelRemove::generated_message_descriptor_data());
            messages.push(ChannelState::generated_message_descriptor_data());
            messages.push(UserRemove::generated_message_descriptor_data());
            messages.push(UserState::generated_message_descriptor_data());
            messages.push(BanList::generated_message_descriptor_data());
            messages.push(TextMessage::generated_message_descriptor_data());
            messages.push(PermissionDenied::generated_message_descriptor_data());
            messages.push(ACL::generated_message_descriptor_data());
            messages.push(QueryUsers::generated_message_descriptor_data());
            messages.push(CryptSetup::generated_message_descriptor_data());
            messages.push(ContextActionModify::generated_message_descriptor_data());
            messages.push(ContextAction::generated_message_descriptor_data());
            messages.push(UserList::generated_message_descriptor_data());
            messages.push(VoiceTarget::generated_message_descriptor_data());
            messages.push(PermissionQuery::generated_message_descriptor_data());
            messages.push(CodecVersion::generated_message_descriptor_data());
            messages.push(UserStats::generated_message_descriptor_data());
            messages.push(RequestBlob::generated_message_descriptor_data());
            messages.push(ServerConfig::generated_message_descriptor_data());
            messages.push(SuggestConfig::generated_message_descriptor_data());
            messages.push(PluginDataTransmission::generated_message_descriptor_data());
            messages.push(ban_list::BanEntry::generated_message_descriptor_data());
            messages.push(acl::ChanGroup::generated_message_descriptor_data());
            messages.push(acl::ChanACL::generated_message_descriptor_data());
            messages.push(user_list::User::generated_message_descriptor_data());
            messages.push(voice_target::Target::generated_message_descriptor_data());
            messages.push(user_stats::Stats::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(4);
            enums.push(reject::RejectType::generated_enum_descriptor_data());
            enums.push(permission_denied::DenyType::generated_enum_descriptor_data());
            enums.push(context_action_modify::Context::generated_enum_descriptor_data());
            enums.push(context_action_modify::Operation::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
